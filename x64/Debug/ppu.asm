; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27050.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__FF24E80D_stdafx@h DB 01H
__84F95A01_denveremu@pch DB 01H
__122CF1B0_xstddef DB 01H
__E53366A2_utility DB 01H
__F2A749D8_streambuf DB 01H
__375B2D08_ostream DB 01H
__548B1832_istream DB 01H
__FB7583FD_xstring DB 01H
__A57BBCE6_stdio@h DB 01H
__D40DD59F_corecrt_stdio_config@h DB 01H
__611638DF_ppu@h DB 01H
__5DCDE773_ppu@cpp DB 01H
__D53377EF_thread DB 01H
__FD4D939F_xthread DB 01H
__D63D055D_chrono DB 01H
__F6B3C2CB_time@h DB 01H
__EEFEAFD5_ratio DB 01H
__5905A80E_functional DB 01H
__246E2F3A_tuple DB 01H
__A2C368DB_fstream DB 01H
__D1FEDD45_ios DB 01H
__5B5D5F1B_wchar@h DB 01H
__BACC91DB_xlocnum DB 01H
__9B0361F4_xiosbase DB 01H
__FD5040F3_system_error DB 01H
__420D52D3_xcall_once@h DB 01H
__244BF7CC_xlocale DB 01H
__223B5856_xfacet DB 01H
__0E7E0F59_memory DB 01H
__A2E616E7_xlocinfo DB 01H
__7A53EED8_ctype@h DB 01H
__C42C8B73_vcruntime_typeinfo@h DB 01H
__F007F164_stdexcept DB 01H
__C334353D_xatomic0@h DB 01H
__1CE3C767_xmemory0 DB 01H
__CDB00636_xutility DB 01H
__7E39D651_iosfwd DB 01H
__BEFE0DB4_string@h DB 01H
__1F77EA16_corecrt_memory@h DB 01H
__7949CB39_exception DB 01H
__9BB4E194_vcruntime_exception@h DB 01H
__ACA0BEE6_malloc@h DB 01H
__5ECFF36E_type_traits DB 01H
__B2D003D7_limits DB 01H
__3736D25A_xtgmath@h DB 01H
__824D367B_cmath DB 01H
__D23EE329_cstdlib DB 01H
__AF9067BE_corecrt_math@h DB 01H
__388D9910_stdlib@h DB 01H
__6BC0FD35_vcruntime_new@h DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	??0ppuram@@QEAA@XZ				; ppuram::ppuram
PUBLIC	??1ppuram@@UEAA@XZ				; ppuram::~ppuram
PUBLIC	?read@ppuram@@UEAAEHH@Z				; ppuram::read
PUBLIC	?write@ppuram@@UEAAXHHE@Z			; ppuram::write
PUBLIC	??_Gppuram@@UEAAPEAXI@Z				; ppuram::`scalar deleting destructor'
PUBLIC	?pal_addr_compute@ppu_pal_ram@@AEAAHH@Z		; ppu_pal_ram::pal_addr_compute
PUBLIC	??0ppu_pal_ram@@QEAA@XZ				; ppu_pal_ram::ppu_pal_ram
PUBLIC	??1ppu_pal_ram@@UEAA@XZ				; ppu_pal_ram::~ppu_pal_ram
PUBLIC	?read@ppu_pal_ram@@UEAAEHH@Z			; ppu_pal_ram::read
PUBLIC	?write@ppu_pal_ram@@UEAAXHHE@Z			; ppu_pal_ram::write
PUBLIC	??_Gppu_pal_ram@@UEAAPEAXI@Z			; ppu_pal_ram::`scalar deleting destructor'
PUBLIC	??0ppu@@QEAA@XZ					; ppu::ppu
PUBLIC	??1ppu@@UEAA@XZ					; ppu::~ppu
PUBLIC	?read@ppu@@UEAAEHH@Z				; ppu::read
PUBLIC	?write@ppu@@UEAAXHHE@Z				; ppu::write
PUBLIC	?rundevice@ppu@@UEAAHH@Z			; ppu::rundevice
PUBLIC	?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z	; ppu::set_char_rom
PUBLIC	?configure_vertical_mirror@ppu@@QEAAXXZ		; ppu::configure_vertical_mirror
PUBLIC	?configure_horizontal_mirror@ppu@@QEAAXXZ	; ppu::configure_horizontal_mirror
PUBLIC	?dma@ppu@@UEAAXPEAE_N1@Z			; ppu::dma
PUBLIC	?getFrameBuffer@ppu@@QEAAPEAXXZ			; ppu::getFrameBuffer
PUBLIC	?isFrameReady@ppu@@QEAA_NXZ			; ppu::isFrameReady
PUBLIC	??_Gppu@@UEAAPEAXI@Z				; ppu::`scalar deleting destructor'
PUBLIC	__JustMyCode_Default
PUBLIC	??_7ppuram@@6B@					; ppuram::`vftable'
PUBLIC	??_7ppu_pal_ram@@6B@				; ppu_pal_ram::`vftable'
PUBLIC	??_7ppu@@6B@					; ppu::`vftable'
PUBLIC	??_C@_0BA@OKGNICPF@Denver?5PPU?5Unit@		; `string'
PUBLIC	??_C@_0P@MFMHDPIH@PPU?5mainram?52k@		; `string'
PUBLIC	??_C@_0BJ@GBIMAOLL@PPU?5palette?5RAM?532?5bytes@ ; `string'
PUBLIC	??_R4ppuram@@6B@				; ppuram::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVppuram@@@8				; ppuram `RTTI Type Descriptor'
PUBLIC	??_R3ppuram@@8					; ppuram::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ppuram@@8					; ppuram::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ppuram@@8				; ppuram::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bus_device@@8			; bus_device::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVbus_device@@@8				; bus_device `RTTI Type Descriptor'
PUBLIC	??_R3bus_device@@8				; bus_device::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bus_device@@8				; bus_device::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@device@@8				; device::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVdevice@@@8				; device `RTTI Type Descriptor'
PUBLIC	??_R3device@@8					; device::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2device@@8					; device::`RTTI Base Class Array'
PUBLIC	??_R4ppu_pal_ram@@6B@				; ppu_pal_ram::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVppu_pal_ram@@@8				; ppu_pal_ram `RTTI Type Descriptor'
PUBLIC	??_R3ppu_pal_ram@@8				; ppu_pal_ram::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ppu_pal_ram@@8				; ppu_pal_ram::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ppu_pal_ram@@8			; ppu_pal_ram::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ppu@@6B@					; ppu::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVppu@@@8					; ppu `RTTI Type Descriptor'
PUBLIC	??_R3ppu@@8					; ppu::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ppu@@8					; ppu::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ppu@@8				; ppu::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	memset:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_strcpy_s:PROC
EXTRN	?rundevice@device@@UEAAHH@Z:PROC		; device::rundevice
EXTRN	?get_device_descriptor@device@@QEAAPEADXZ:PROC	; device::get_device_descriptor
EXTRN	?dma@device@@UEAAXPEAE_N1@Z:PROC		; device::dma
EXTRN	??0bus_device@@QEAA@XZ:PROC			; bus_device::bus_device
EXTRN	??1bus_device@@UEAA@XZ:PROC			; bus_device::~bus_device
EXTRN	?swappins@bus_device@@QEAAXHH@Z:PROC		; bus_device::swappins
EXTRN	?groundpin@bus_device@@QEAAXH@Z:PROC		; bus_device::groundpin
EXTRN	?resetpins_to_default@bus_device@@QEAAXXZ:PROC	; bus_device::resetpins_to_default
EXTRN	??0bus@@QEAA@XZ:PROC				; bus::bus
EXTRN	??1bus@@QEAA@XZ:PROC				; bus::~bus
EXTRN	?writememory@bus@@QEAAXHE@Z:PROC		; bus::writememory
EXTRN	?readmemory@bus@@QEAAEH@Z:PROC			; bus::readmemory
EXTRN	?registerdevice@bus@@QEAAXPEAVbus_device@@@Z:PROC ; bus::registerdevice
EXTRN	?removedevice_select_base@bus@@QEAAXH@Z:PROC	; bus::removedevice_select_base
EXTRN	??_Eppuram@@UEAAPEAXI@Z:PROC			; ppuram::`vector deleting destructor'
EXTRN	??_Eppu_pal_ram@@UEAAPEAXI@Z:PROC		; ppu_pal_ram::`vector deleting destructor'
EXTRN	??_Eppu@@UEAAPEAXI@Z:PROC			; ppu::`vector deleting destructor'
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ppuram@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+209
	DD	imagerel $unwind$??0ppuram@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ppuram@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ppuram@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ppuram@@QEAA@XZ@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0ppuram@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ppuram@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$??1ppuram@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?read@ppuram@@UEAAEHH@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?read@ppuram@@UEAAEHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?write@ppuram@@UEAAXHHE@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?write@ppuram@@UEAAXHHE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gppuram@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+105
	DD	imagerel $unwind$??_Gppuram@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pal_addr_compute@ppu_pal_ram@@AEAAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+135
	DD	imagerel $unwind$?pal_addr_compute@ppu_pal_ram@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ppu_pal_ram@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+209
	DD	imagerel $unwind$??0ppu_pal_ram@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ppu_pal_ram@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ppu_pal_ram@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ppu_pal_ram@@QEAA@XZ@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0ppu_pal_ram@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ppu_pal_ram@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$??1ppu_pal_ram@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?read@ppu_pal_ram@@UEAAEHH@Z DD imagerel $LN6
	DD	imagerel $LN6+216
	DD	imagerel $unwind$?read@ppu_pal_ram@@UEAAEHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?write@ppu_pal_ram@@UEAAXHHE@Z DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$?write@ppu_pal_ram@@UEAAXHHE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gppu_pal_ram@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+105
	DD	imagerel $unwind$??_Gppu_pal_ram@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ppu@@QEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+413
	DD	imagerel $unwind$??0ppu@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ppu@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ppu@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ppu@@QEAA@XZ@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0ppu@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ppu@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0ppu@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0ppu@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$1@?0???0ppu@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0ppu@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???0ppu@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???0ppu@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$2@?0???0ppu@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???0ppu@@QEAA@XZ@4HA DD imagerel ?dtor$3@?0???0ppu@@QEAA@XZ@4HA
	DD	imagerel ?dtor$3@?0???0ppu@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$3@?0???0ppu@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ppu@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+242
	DD	imagerel $unwind$??1ppu@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?read@ppu@@UEAAEHH@Z DD imagerel $LN12
	DD	imagerel $LN12+437
	DD	imagerel $unwind$?read@ppu@@UEAAEHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?write@ppu@@UEAAXHHE@Z DD imagerel $LN48
	DD	imagerel $LN48+1671
	DD	imagerel $unwind$?write@ppu@@UEAAXHHE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rundevice@ppu@@UEAAHH@Z DD imagerel $LN129
	DD	imagerel $LN129+7110
	DD	imagerel $unwind$?rundevice@ppu@@UEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?configure_vertical_mirror@ppu@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$?configure_vertical_mirror@ppu@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?configure_horizontal_mirror@ppu@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+143
	DD	imagerel $unwind$?configure_horizontal_mirror@ppu@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dma@ppu@@UEAAXPEAE_N1@Z DD imagerel $LN4
	DD	imagerel $LN4+167
	DD	imagerel $unwind$?dma@ppu@@UEAAXPEAE_N1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getFrameBuffer@ppu@@QEAAPEAXXZ DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?getFrameBuffer@ppu@@QEAAPEAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isFrameReady@ppu@@QEAA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$?isFrameReady@ppu@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gppu@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+105
	DD	imagerel $unwind$??_Gppu@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@ppu@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ppu@@8 DD imagerel ??_R0?AVppu@@@8	; ppu::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ppu@@8
rdata$r	ENDS
;	COMDAT ??_R2ppu@@8
rdata$r	SEGMENT
??_R2ppu@@8 DD	imagerel ??_R1A@?0A@EA@ppu@@8		; ppu::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bus_device@@8
	DD	imagerel ??_R1A@?0A@EA@device@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ppu@@8
rdata$r	SEGMENT
??_R3ppu@@8 DD	00H					; ppu::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2ppu@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVppu@@@8
data$r	SEGMENT
??_R0?AVppu@@@8 DQ FLAT:??_7type_info@@6B@		; ppu `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVppu@@', 00H
data$r	ENDS
;	COMDAT ??_R4ppu@@6B@
rdata$r	SEGMENT
??_R4ppu@@6B@ DD 01H					; ppu::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVppu@@@8
	DD	imagerel ??_R3ppu@@8
	DD	imagerel ??_R4ppu@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ppu_pal_ram@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ppu_pal_ram@@8 DD imagerel ??_R0?AVppu_pal_ram@@@8 ; ppu_pal_ram::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ppu_pal_ram@@8
rdata$r	ENDS
;	COMDAT ??_R2ppu_pal_ram@@8
rdata$r	SEGMENT
??_R2ppu_pal_ram@@8 DD imagerel ??_R1A@?0A@EA@ppu_pal_ram@@8 ; ppu_pal_ram::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bus_device@@8
	DD	imagerel ??_R1A@?0A@EA@device@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ppu_pal_ram@@8
rdata$r	SEGMENT
??_R3ppu_pal_ram@@8 DD 00H				; ppu_pal_ram::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2ppu_pal_ram@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVppu_pal_ram@@@8
data$r	SEGMENT
??_R0?AVppu_pal_ram@@@8 DQ FLAT:??_7type_info@@6B@	; ppu_pal_ram `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVppu_pal_ram@@', 00H
data$r	ENDS
;	COMDAT ??_R4ppu_pal_ram@@6B@
rdata$r	SEGMENT
??_R4ppu_pal_ram@@6B@ DD 01H				; ppu_pal_ram::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVppu_pal_ram@@@8
	DD	imagerel ??_R3ppu_pal_ram@@8
	DD	imagerel ??_R4ppu_pal_ram@@6B@
rdata$r	ENDS
;	COMDAT ??_R2device@@8
rdata$r	SEGMENT
??_R2device@@8 DD imagerel ??_R1A@?0A@EA@device@@8	; device::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3device@@8
rdata$r	SEGMENT
??_R3device@@8 DD 00H					; device::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2device@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVdevice@@@8
data$r	SEGMENT
??_R0?AVdevice@@@8 DQ FLAT:??_7type_info@@6B@		; device `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVdevice@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@device@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@device@@8 DD imagerel ??_R0?AVdevice@@@8	; device::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3device@@8
rdata$r	ENDS
;	COMDAT ??_R2bus_device@@8
rdata$r	SEGMENT
??_R2bus_device@@8 DD imagerel ??_R1A@?0A@EA@bus_device@@8 ; bus_device::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@device@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bus_device@@8
rdata$r	SEGMENT
??_R3bus_device@@8 DD 00H				; bus_device::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bus_device@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbus_device@@@8
data$r	SEGMENT
??_R0?AVbus_device@@@8 DQ FLAT:??_7type_info@@6B@	; bus_device `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbus_device@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bus_device@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bus_device@@8 DD imagerel ??_R0?AVbus_device@@@8 ; bus_device::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bus_device@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ppuram@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ppuram@@8 DD imagerel ??_R0?AVppuram@@@8	; ppuram::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ppuram@@8
rdata$r	ENDS
;	COMDAT ??_R2ppuram@@8
rdata$r	SEGMENT
??_R2ppuram@@8 DD imagerel ??_R1A@?0A@EA@ppuram@@8	; ppuram::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bus_device@@8
	DD	imagerel ??_R1A@?0A@EA@device@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ppuram@@8
rdata$r	SEGMENT
??_R3ppuram@@8 DD 00H					; ppuram::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2ppuram@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVppuram@@@8
data$r	SEGMENT
??_R0?AVppuram@@@8 DQ FLAT:??_7type_info@@6B@		; ppuram `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVppuram@@', 00H
data$r	ENDS
;	COMDAT ??_R4ppuram@@6B@
rdata$r	SEGMENT
??_R4ppuram@@6B@ DD 01H					; ppuram::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVppuram@@@8
	DD	imagerel ??_R3ppuram@@8
	DD	imagerel ??_R4ppuram@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BJ@GBIMAOLL@PPU?5palette?5RAM?532?5bytes@
CONST	SEGMENT
??_C@_0BJ@GBIMAOLL@PPU?5palette?5RAM?532?5bytes@ DB 'PPU palette RAM 32 b'
	DB	'ytes', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MFMHDPIH@PPU?5mainram?52k@
CONST	SEGMENT
??_C@_0P@MFMHDPIH@PPU?5mainram?52k@ DB 'PPU mainram 2k', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OKGNICPF@Denver?5PPU?5Unit@
CONST	SEGMENT
??_C@_0BA@OKGNICPF@Denver?5PPU?5Unit@ DB 'Denver PPU Unit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7ppu@@6B@
CONST	SEGMENT
??_7ppu@@6B@ DQ	FLAT:??_R4ppu@@6B@			; ppu::`vftable'
	DQ	FLAT:?rundevice@ppu@@UEAAHH@Z
	DQ	FLAT:?dma@ppu@@UEAAXPEAE_N1@Z
	DQ	FLAT:??_Eppu@@UEAAPEAXI@Z
	DQ	FLAT:?write@ppu@@UEAAXHHE@Z
	DQ	FLAT:?read@ppu@@UEAAEHH@Z
CONST	ENDS
;	COMDAT ??_7ppu_pal_ram@@6B@
CONST	SEGMENT
??_7ppu_pal_ram@@6B@ DQ FLAT:??_R4ppu_pal_ram@@6B@	; ppu_pal_ram::`vftable'
	DQ	FLAT:?rundevice@device@@UEAAHH@Z
	DQ	FLAT:?dma@device@@UEAAXPEAE_N1@Z
	DQ	FLAT:??_Eppu_pal_ram@@UEAAPEAXI@Z
	DQ	FLAT:?write@ppu_pal_ram@@UEAAXHHE@Z
	DQ	FLAT:?read@ppu_pal_ram@@UEAAEHH@Z
CONST	ENDS
;	COMDAT ??_7ppuram@@6B@
CONST	SEGMENT
??_7ppuram@@6B@ DQ FLAT:??_R4ppuram@@6B@		; ppuram::`vftable'
	DQ	FLAT:?rundevice@device@@UEAAHH@Z
	DQ	FLAT:?dma@device@@UEAAXPEAE_N1@Z
	DQ	FLAT:??_Eppuram@@UEAAPEAXI@Z
	DQ	FLAT:?write@ppuram@@UEAAXHHE@Z
	DQ	FLAT:?read@ppuram@@UEAAEHH@Z
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gppu@@UEAAPEAXI@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isFrameReady@ppu@@QEAA_NXZ DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getFrameBuffer@ppu@@QEAAPEAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dma@ppu@@UEAAXPEAE_N1@Z DD 025053901H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?configure_horizontal_mirror@ppu@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?configure_vertical_mirror@ppu@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rundevice@ppu@@UEAAHH@Z DD 025052e01H
	DD	01122317H
	DD	0700b009bH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?write@ppu@@UEAAXHHE@Z DD 025053801H
	DD	011c2321H
	DD	070150021H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?read@ppu@@UEAAEHH@Z DD 025053301H
	DD	0117231cH
	DD	070100029H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ppu@@UEAA@XZ DD imagerel ??1ppu@@UEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1ppu@@UEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1ppu@@UEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ppu@@UEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1ppu@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???0ppu@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0ppu@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ppu@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ppu@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ppu@@QEAA@XZ DD imagerel ??0ppu@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0ppu@@QEAA@XZ+78
	DD	00H
	DD	imagerel ??0ppu@@QEAA@XZ+117
	DD	01H
	DD	imagerel ??0ppu@@QEAA@XZ+139
	DD	02H
	DD	imagerel ??0ppu@@QEAA@XZ+161
	DD	03H
	DD	imagerel ??0ppu@@QEAA@XZ+396
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ppu@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0ppu@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0ppu@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0ppu@@QEAA@XZ@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0???0ppu@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ppu@@QEAA@XZ DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$??0ppu@@QEAA@XZ
	DD	00H
	DD	00H
	DD	06H
	DD	imagerel $ip2state$??0ppu@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ppu@@QEAA@XZ DD 025053511H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ppu@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gppu_pal_ram@@UEAAPEAXI@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?write@ppu_pal_ram@@UEAAXHHE@Z DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?read@ppu_pal_ram@@UEAAEHH@Z DD 025053301H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ppu_pal_ram@@UEAA@XZ DD imagerel ??1ppu_pal_ram@@UEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1ppu_pal_ram@@UEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1ppu_pal_ram@@UEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ppu_pal_ram@@UEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1ppu_pal_ram@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ppu_pal_ram@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ppu_pal_ram@@QEAA@XZ DD imagerel ??0ppu_pal_ram@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0ppu_pal_ram@@QEAA@XZ+78
	DD	00H
	DD	imagerel ??0ppu_pal_ram@@QEAA@XZ+192
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ppu_pal_ram@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0ppu_pal_ram@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ppu_pal_ram@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0ppu_pal_ram@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0ppu_pal_ram@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ppu_pal_ram@@QEAA@XZ DD 025053511H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ppu_pal_ram@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pal_addr_compute@ppu_pal_ram@@AEAAHH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gppuram@@UEAAPEAXI@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?write@ppuram@@UEAAXHHE@Z DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?read@ppuram@@UEAAEHH@Z DD 025053301H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ppuram@@UEAA@XZ DD imagerel ??1ppuram@@UEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1ppuram@@UEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1ppuram@@UEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ppuram@@UEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1ppuram@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ppuram@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ppuram@@QEAA@XZ DD imagerel ??0ppuram@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0ppuram@@QEAA@XZ+78
	DD	00H
	DD	imagerel ??0ppuram@@QEAA@XZ+192
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ppuram@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0ppuram@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ppuram@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0ppuram@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0ppuram@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ppuram@@QEAA@XZ DD 025053511H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ppuram@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX_K@Z DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX@Z DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gppu@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gppu@@UEAAPEAXI@Z PROC				; ppu::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1ppu@@UEAA@XZ				; ppu::~ppu
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 712				; 000002c8H
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gppu@@UEAAPEAXI@Z ENDP				; ppu::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?isFrameReady@ppu@@QEAA_NXZ
_TEXT	SEGMENT
retval$ = 4
this$ = 256
?isFrameReady@ppu@@QEAA_NXZ PROC			; ppu::isFrameReady, COMDAT

; 493  : bool	ppu::isFrameReady() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 494  : 	bool retval = frameready;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+232]
	mov	BYTE PTR retval$[rbp], al

; 495  : 	frameready = false;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+232], 0

; 496  : 	return retval;

	movzx	eax, BYTE PTR retval$[rbp]

; 497  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?isFrameReady@ppu@@QEAA_NXZ ENDP			; ppu::isFrameReady
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?getFrameBuffer@ppu@@QEAAPEAXXZ
_TEXT	SEGMENT
this$ = 224
?getFrameBuffer@ppu@@QEAAPEAXXZ PROC			; ppu::getFrameBuffer, COMDAT

; 489  : void*	ppu::getFrameBuffer() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 490  : 	return framebuffer;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+224]

; 491  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?getFrameBuffer@ppu@@QEAAPEAXXZ ENDP			; ppu::getFrameBuffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?dma@ppu@@UEAAXPEAE_N1@Z
_TEXT	SEGMENT
buf$1 = 8
this$ = 256
data$ = 264
is_output$ = 272
started$ = 280
?dma@ppu@@UEAAXPEAE_N1@Z PROC				; ppu::dma, COMDAT

; 482  : void	ppu::dma(byte *data, bool is_output, bool started) {

$LN4:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 483  : 	if (is_output) {

	movzx	eax, BYTE PTR is_output$[rbp]
	test	eax, eax
	je	SHORT $LN2@dma

; 484  : 		char * buf = (char *)oam;

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 448				; 000001c0H
	mov	QWORD PTR buf$1[rbp], rax

; 485  : 		buf[oamaddr++] = *data;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+704]
	mov	rcx, QWORD PTR buf$1[rbp]
	mov	rdx, QWORD PTR data$[rbp]
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+704]
	inc	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+704], al
$LN2@dma:

; 486  : 	}
; 487  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?dma@ppu@@UEAAXPEAE_N1@Z ENDP				; ppu::dma
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?configure_horizontal_mirror@ppu@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?configure_horizontal_mirror@ppu@@QEAAXXZ PROC		; ppu::configure_horizontal_mirror, COMDAT

; 476  : void	ppu::configure_horizontal_mirror() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 477  : 	vram.resetpins_to_default();

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 368				; 00000170H
	mov	rcx, rax
	call	?resetpins_to_default@bus_device@@QEAAXXZ ; bus_device::resetpins_to_default

; 478  : 	vram.swappins(10, 11);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 368				; 00000170H
	mov	r8d, 11
	mov	edx, 10
	mov	rcx, rax
	call	?swappins@bus_device@@QEAAXHH@Z		; bus_device::swappins

; 479  : 	vram.groundpin(10);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 368				; 00000170H
	mov	edx, 10
	mov	rcx, rax
	call	?groundpin@bus_device@@QEAAXH@Z		; bus_device::groundpin

; 480  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?configure_horizontal_mirror@ppu@@QEAAXXZ ENDP		; ppu::configure_horizontal_mirror
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?configure_vertical_mirror@ppu@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?configure_vertical_mirror@ppu@@QEAAXXZ PROC		; ppu::configure_vertical_mirror, COMDAT

; 472  : void	ppu::configure_vertical_mirror() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 473  : 	vram.resetpins_to_default();

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 368				; 00000170H
	mov	rcx, rax
	call	?resetpins_to_default@bus_device@@QEAAXXZ ; bus_device::resetpins_to_default

; 474  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?configure_vertical_mirror@ppu@@QEAAXXZ ENDP		; ppu::configure_vertical_mirror
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z
_TEXT	SEGMENT
this$ = 224
vdata$ = 232
?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z PROC		; ppu::set_char_rom, COMDAT

; 464  : void	ppu::set_char_rom(bus_device *vdata) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 465  : 	// first remove any linked rom/rams!
; 466  : 	// it is destructive.
; 467  : 	vbus.removedevice_select_base(0x0000);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 240				; 000000f0H
	xor	edx, edx
	mov	rcx, rax
	call	?removedevice_select_base@bus@@QEAAXH@Z	; bus::removedevice_select_base

; 468  : 	// reregister
; 469  : 	vbus.registerdevice(vdata);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 240				; 000000f0H
	mov	rdx, QWORD PTR vdata$[rbp]
	mov	rcx, rax
	call	?registerdevice@bus@@QEAAXPEAVbus_device@@@Z ; bus::registerdevice

; 470  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z ENDP		; ppu::set_char_rom
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?rundevice@ppu@@UEAAHH@Z
_TEXT	SEGMENT
i$1 = 4
attr_address$2 = 36
ab$3 = 68
pattern_address$4 = 100
pattern_address$5 = 132
color$6 = 164
cb1$7 = 196
cb2$8 = 228
secaddr$9 = 260
odd$10 = 292
scancomp$11 = 324
cs$12 = 356
ltile$13 = 388
ix$14 = 420
pattern_address$15 = 452
ltile$16 = 484
ix$17 = 516
pattern_address$18 = 548
y$19 = 580
i$20 = 612
pix$21 = 644
spr_palette$22 = 676
pix_mux$23 = 708
palentry$24 = 740
color$25 = 772
tv1895 = 1172
tv1397 = 1172
tv1248 = 1172
tv1156 = 1172
tv1135 = 1172
tv1116 = 1172
tv839 = 1172
tv812 = 1172
tv741 = 1172
tv714 = 1172
tv540 = 1172
tv510 = 1172
tv477 = 1172
tv447 = 1172
tv289 = 1172
tv82 = 1172
tv1417 = 1176
tv1416 = 1176
tv1411 = 1176
tv1253 = 1176
tv1166 = 1176
tv1145 = 1176
tv513 = 1176
tv296 = 1176
tv258 = 1176
tv87 = 1176
tv1259 = 1180
tv260 = 1184
this$ = 1232
ticks$ = 1240
?rundevice@ppu@@UEAAHH@Z PROC				; ppu::rundevice, COMDAT

; 134  : int		ppu::rundevice(int ticks) {

$LN129:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 1240				; 000004d8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 310				; 00000136H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+1272]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 135  : 	// run the PPU..
; 136  : 	for (int i = 0; i < ticks; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@rundevice
$LN2@rundevice:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@rundevice:
	mov	eax, DWORD PTR ticks$[rbp]
	cmp	DWORD PTR i$1[rbp], eax
	jge	$LN3@rundevice

; 137  : 		if ((ppumask.showbg || ppumask.showspr) && !((scanline>=240) && (scanline<=260))) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+82]
	test	eax, eax
	jne	SHORT $LN11@rundevice
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+83]
	test	eax, eax
	je	$LN10@rundevice
$LN11@rundevice:
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 240		; 000000f0H
	jl	SHORT $LN12@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 260		; 00000104H
	jle	$LN10@rundevice
$LN12@rundevice:

; 138  : 			// loading cycles.
; 139  : 			if (((cycle >= 1) && (cycle <= 256)) | ((cycle >= 321) && (cycle <= 340))) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 1
	jl	SHORT $LN91@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 256		; 00000100H
	jg	SHORT $LN91@rundevice
	mov	DWORD PTR tv82[rbp], 1
	jmp	SHORT $LN92@rundevice
$LN91@rundevice:
	mov	DWORD PTR tv82[rbp], 0
$LN92@rundevice:
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 321		; 00000141H
	jl	SHORT $LN93@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 340		; 00000154H
	jg	SHORT $LN93@rundevice
	mov	DWORD PTR tv87[rbp], 1
	jmp	SHORT $LN94@rundevice
$LN93@rundevice:
	mov	DWORD PTR tv87[rbp], 0
$LN94@rundevice:
	mov	eax, DWORD PTR tv87[rbp]
	mov	ecx, DWORD PTR tv82[rbp]
	or	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	$LN13@rundevice

; 140  : 				if (((cycle - 1) % 8) == 1) {

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+220]
	dec	eax
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	cmp	eax, 1
	jne	SHORT $LN14@rundevice

; 141  : 					// load name table shift register.
; 142  : 					ppu_internal.shiftreg_nametable = vbus.readmemory(0x2000 | (ppu_internal.v_register & 0x0FFF));

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, 4095				; 00000fffH
	bts	eax, 13
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	mov	edx, eax
	call	?readmemory@bus@@QEAAEH@Z		; bus::readmemory
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+201], al
	jmp	$LN15@rundevice
$LN14@rundevice:

; 143  : 				}
; 144  : 				else if (((cycle - 1) % 8) == 3) {					

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+220]
	dec	eax
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	cmp	eax, 3
	jne	SHORT $LN16@rundevice

; 145  : 					// load attribute table shift register.
; 146  : 					word attr_address = ppu_internal.v_register & ~0x2000;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	btr	eax, 13
	mov	WORD PTR attr_address$2[rbp], ax

; 147  : 					attr_address = 0x03C0 | (attr_address & 0x0C00) | ((attr_address >> 4) & 0x0038) | ((attr_address >> 2) & 0x0007);

	movzx	eax, WORD PTR attr_address$2[rbp]
	and	eax, 3072				; 00000c00H
	or	eax, 960				; 000003c0H
	movzx	ecx, WORD PTR attr_address$2[rbp]
	sar	ecx, 4
	and	ecx, 56					; 00000038H
	or	eax, ecx
	movzx	ecx, WORD PTR attr_address$2[rbp]
	sar	ecx, 2
	and	ecx, 7
	or	eax, ecx
	mov	WORD PTR attr_address$2[rbp], ax

; 148  : 					// better fetch the palette entry @ latch mode, finding it later is incredibly difficult.
; 149  : 					byte ab = vbus.readmemory(attr_address | 0x2000);

	movzx	eax, WORD PTR attr_address$2[rbp]
	bts	eax, 13
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	mov	edx, eax
	call	?readmemory@bus@@QEAAEH@Z		; bus::readmemory
	mov	BYTE PTR ab$3[rbp], al

; 150  : 					ppu_internal.shiftreg_attribute_latch = ab;

	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR ab$3[rbp]
	mov	BYTE PTR [rax+114], cl
	jmp	$LN17@rundevice
$LN16@rundevice:

; 151  : 				}
; 152  : 				else if (((cycle - 1) % 8) == 5) {

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+220]
	dec	eax
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	cmp	eax, 5
	jne	SHORT $LN18@rundevice

; 153  : 					// load pattern table tile low
; 154  : 					ppu_internal.y_shift = (ppu_internal.v_register & 0x7000) >> 12;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, 28672				; 00007000H
	sar	eax, 12
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+98], al

; 155  : 					word pattern_address = (ppuctrl.bg_0x1000 << 12) | ((word)ppu_internal.shiftreg_nametable << 4) | ppu_internal.y_shift;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+75]
	shl	eax, 12
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+201]
	shl	ecx, 4
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+98]
	or	eax, ecx
	mov	WORD PTR pattern_address$4[rbp], ax

; 156  : 					// ppu_internal.shiftregs_pattern_par[0] = vbus->readmemory(pattern_address);<-- hack
; 157  : 					ppu_internal.shiftregs_pattern_latch = (vbus.readmemory(pattern_address)); // read to lower part.

	movzx	eax, WORD PTR pattern_address$4[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	mov	edx, eax
	call	?readmemory@bus@@QEAAEH@Z		; bus::readmemory
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+104], al
	jmp	$LN19@rundevice
$LN18@rundevice:

; 158  : 				}
; 159  : 				else if (((cycle - 1) % 8) == 7) {

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+220]
	dec	eax
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	cmp	eax, 7
	jne	$LN20@rundevice

; 160  : 					// load pattern table tile high
; 161  : 					word pattern_address = (ppuctrl.bg_0x1000 << 12) | ((word)ppu_internal.shiftreg_nametable << 4) | 8 | ppu_internal.y_shift;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+75]
	shl	eax, 12
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+201]
	shl	ecx, 4
	or	eax, ecx
	or	eax, 8
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+98]
	or	eax, ecx
	mov	WORD PTR pattern_address$5[rbp], ax

; 162  : 					//ppu_internal.shiftregs_pattern_par[1] = vbus->readmemory(pattern_address);
; 163  : 					if (cycle >= 321) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 321		; 00000141H
	jl	$LN21@rundevice

; 164  : 						ppu_internal.shiftregs_pattern[0] <<= 8; // clean upper part.

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+106]
	shl	ax, 8
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+106], ax

; 165  : 						ppu_internal.shiftregs_pattern[1] <<= 8; // clean upper part.

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+106]
	shl	ax, 8
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+106], ax

; 166  : 						ppu_internal.shiftreg_attribute[0] <<= 8; // clean upper part.

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+110]
	shl	ax, 8
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+110], ax

; 167  : 						ppu_internal.shiftreg_attribute[1] <<= 8; // clean upper part.

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+110]
	shl	ax, 8
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+110], ax
$LN21@rundevice:

; 168  : 					}
; 169  : 					ppu_internal.shiftregs_pattern[1] |= (vbus.readmemory(pattern_address)); // read to lower part.

	mov	eax, 2
	imul	rax, rax, 1
	mov	QWORD PTR tv258[rbp], rax
	movzx	ecx, WORD PTR pattern_address$5[rbp]
	mov	rdx, QWORD PTR this$[rbp]
	add	rdx, 240				; 000000f0H
	mov	QWORD PTR tv260[rbp], rdx
	mov	edx, ecx
	mov	rcx, QWORD PTR tv260[rbp]
	call	?readmemory@bus@@QEAAEH@Z		; bus::readmemory
	movzx	eax, al
	mov	rcx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR tv258[rbp]
	movzx	ecx, WORD PTR [rcx+rdx+106]
	or	ecx, eax
	mov	eax, ecx
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+106], ax

; 170  : 					ppu_internal.shiftregs_pattern[0] |= ppu_internal.shiftregs_pattern_latch;

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+104]
	mov	rdx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rdx+rax+106]
	or	eax, ecx
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+106], ax

; 171  : 
; 172  : 					byte color = ((ppu_internal.shiftreg_attribute_latch) >> (((((ppu_internal.v_register & 0x1F) >> 1) % 2) << 1) | ((((ppu_internal.v_register & 0x3E0) >> 6) % 2) << 2)) & 0x03);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+114]
	mov	DWORD PTR tv289[rbp], eax
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+102]
	and	ecx, 31
	sar	ecx, 1
	mov	eax, ecx
	cdq
	and	eax, 1
	xor	eax, edx
	sub	eax, edx
	shl	eax, 1
	mov	DWORD PTR tv296[rbp], eax
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+102]
	and	ecx, 992				; 000003e0H
	sar	ecx, 6
	mov	eax, ecx
	cdq
	and	eax, 1
	xor	eax, edx
	sub	eax, edx
	shl	eax, 2
	mov	ecx, DWORD PTR tv296[rbp]
	or	ecx, eax
	mov	eax, ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv289[rbp]
	sar	eax, cl
	and	eax, 3
	mov	BYTE PTR color$6[rbp], al

; 173  : 					byte cb1 = color & 0x01;

	movzx	eax, BYTE PTR color$6[rbp]
	and	eax, 1
	mov	BYTE PTR cb1$7[rbp], al

; 174  : 					byte cb2 = (color >> 1) & 0x01;					

	movzx	eax, BYTE PTR color$6[rbp]
	sar	eax, 1
	and	eax, 1
	mov	BYTE PTR cb2$8[rbp], al

; 175  : 					ppu_internal.shiftreg_attribute[0] |= cb1 | (cb1 << 1) | (cb1 << 2) | (cb1 << 3) | (cb1 << 4) | (cb1 << 5) | (cb1 << 6) | (cb1 << 7);

	mov	eax, 2
	imul	rax, rax, 0
	movzx	ecx, BYTE PTR cb1$7[rbp]
	movzx	edx, BYTE PTR cb1$7[rbp]
	shl	edx, 1
	or	ecx, edx
	movzx	edx, BYTE PTR cb1$7[rbp]
	shl	edx, 2
	or	ecx, edx
	movzx	edx, BYTE PTR cb1$7[rbp]
	shl	edx, 3
	or	ecx, edx
	movzx	edx, BYTE PTR cb1$7[rbp]
	shl	edx, 4
	or	ecx, edx
	movzx	edx, BYTE PTR cb1$7[rbp]
	shl	edx, 5
	or	ecx, edx
	movzx	edx, BYTE PTR cb1$7[rbp]
	shl	edx, 6
	or	ecx, edx
	movzx	edx, BYTE PTR cb1$7[rbp]
	shl	edx, 7
	or	ecx, edx
	mov	rdx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rdx+rax+110]
	or	eax, ecx
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+110], ax

; 176  : 					ppu_internal.shiftreg_attribute[1] |= cb2 | (cb2 << 1) | (cb2 << 2) | (cb2 << 3) | (cb2 << 4) | (cb2 << 5) | (cb2 << 6) | (cb2 << 7);

	mov	eax, 2
	imul	rax, rax, 1
	movzx	ecx, BYTE PTR cb2$8[rbp]
	movzx	edx, BYTE PTR cb2$8[rbp]
	shl	edx, 1
	or	ecx, edx
	movzx	edx, BYTE PTR cb2$8[rbp]
	shl	edx, 2
	or	ecx, edx
	movzx	edx, BYTE PTR cb2$8[rbp]
	shl	edx, 3
	or	ecx, edx
	movzx	edx, BYTE PTR cb2$8[rbp]
	shl	edx, 4
	or	ecx, edx
	movzx	edx, BYTE PTR cb2$8[rbp]
	shl	edx, 5
	or	ecx, edx
	movzx	edx, BYTE PTR cb2$8[rbp]
	shl	edx, 6
	or	ecx, edx
	movzx	edx, BYTE PTR cb2$8[rbp]
	shl	edx, 7
	or	ecx, edx
	mov	rdx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rdx+rax+110]
	or	eax, ecx
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+110], ax

; 177  : 
; 178  : 					// last fetch also update Coarse X (v register) (loopy_v verti)
; 179  : 					if ((ppu_internal.v_register & 0x001F) == 31) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, 31
	cmp	eax, 31
	jne	SHORT $LN22@rundevice

; 180  : 						ppu_internal.v_register &= ~0x001F;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, -32				; ffffffffffffffe0H
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax

; 181  : 						ppu_internal.v_register ^= 0x0400;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	btc	eax, 10
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax

; 182  : 					}
; 183  : 					else {

	jmp	SHORT $LN23@rundevice
$LN22@rundevice:

; 184  : 						ppu_internal.v_register++;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	inc	ax
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax
$LN23@rundevice:
$LN20@rundevice:
$LN19@rundevice:
$LN17@rundevice:
$LN15@rundevice:
$LN13@rundevice:

; 185  : 					}
; 186  : 				}
; 187  : 			}
; 188  : 			// secondary OAM reset (cycli 1--64)
; 189  : 			if ((cycle >= 1) && (cycle <= 64)) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 1
	jl	$LN24@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 64			; 00000040H
	jg	$LN24@rundevice

; 190  : 				ppu_internal.oam_clearing = true;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+166], 1

; 191  : 				byte secaddr = (cycle - 1) % 8;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+220]
	dec	eax
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	mov	BYTE PTR secaddr$9[rbp], al

; 192  : 				memset(&ppu_internal.secoam[(cycle - 1) % 8], 0xFF, 4);

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+220]
	dec	eax
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	cdqe
	mov	rcx, QWORD PTR this$[rbp]
	lea	rax, QWORD PTR [rcx+rax*4+115]
	mov	r8d, 4
	mov	edx, 255				; 000000ffH
	mov	rcx, rax
	call	memset

; 193  : 				ppu_internal.n = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+160], 0

; 194  : 				ppu_internal.m = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+161], 0

; 195  : 				ppu_internal.sn = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+162], 0

; 196  : 				ppu_internal.oam_evald = false;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+168], 0
$LN24@rundevice:

; 197  : 			}
; 198  : 			// sprite eval (cycli 65--256)
; 199  : 			if ((cycle >= 65) && (cycle <= 256)) {				

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 65			; 00000041H
	jl	$LN25@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 256		; 00000100H
	jg	$LN25@rundevice

; 200  : 				ppu_internal.oam_clearing = false;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+166], 0

; 201  : 				bool odd = ((cycle - 1) % 2) > 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+220]
	dec	eax
	cdq
	and	eax, 1
	xor	eax, edx
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN95@rundevice
	mov	DWORD PTR tv447[rbp], 1
	jmp	SHORT $LN96@rundevice
$LN95@rundevice:
	mov	DWORD PTR tv447[rbp], 0
$LN96@rundevice:
	movzx	eax, BYTE PTR tv447[rbp]
	mov	BYTE PTR odd$10[rbp], al

; 202  : 				if (odd) {

	movzx	eax, BYTE PTR odd$10[rbp]
	test	eax, eax
	je	SHORT $LN26@rundevice

; 203  : 					// odd cycle (read from primary OAM)
; 204  : 					ppu_internal.secoamb = (byte *)&oam[ppu_internal.n];

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	mov	rcx, QWORD PTR this$[rbp]
	lea	rax, QWORD PTR [rcx+rax*4+448]
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+152], rax

; 205  : 					ppu_internal.buffer_oam_read = ppu_internal.secoamb[ppu_internal.m];

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+161]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx+165], al

; 206  : 				} else {

	jmp	$LN27@rundevice
$LN26@rundevice:

; 207  : 					// even cycle (write to secondary OAM)
; 208  : 					if (ppu_internal.m == 0) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+161]
	test	eax, eax
	jne	$LN28@rundevice

; 209  : 						int scancomp = (scanline == 261) ? -1 : scanline;

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 261		; 00000105H
	jne	SHORT $LN97@rundevice
	mov	DWORD PTR tv477[rbp], -1
	jmp	SHORT $LN98@rundevice
$LN97@rundevice:
	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+212]
	mov	DWORD PTR tv477[rbp], eax
$LN98@rundevice:
	mov	eax, DWORD PTR tv477[rbp]
	mov	DWORD PTR scancomp$11[rbp], eax

; 210  : 						if ((ppu_internal.sn < 8) && !ppu_internal.oam_evald) ppu_internal.secoam[ppu_internal.sn].y = ppu_internal.buffer_oam_read;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+162]
	cmp	eax, 8
	jge	SHORT $LN29@rundevice
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+168]
	test	eax, eax
	jne	SHORT $LN29@rundevice
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+162]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR [rdx+165]
	mov	BYTE PTR [rcx+rax*4+115], dl
$LN29@rundevice:

; 211  : 						ppu_internal.oam_copy =

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+165]
	cmp	DWORD PTR scancomp$11[rbp], eax
	jl	SHORT $LN101@rundevice
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+76]
	test	eax, eax
	je	SHORT $LN99@rundevice
	mov	DWORD PTR tv510[rbp], 16
	jmp	SHORT $LN100@rundevice
$LN99@rundevice:
	mov	DWORD PTR tv510[rbp], 8
$LN100@rundevice:
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+165]
	add	eax, DWORD PTR tv510[rbp]
	cmp	DWORD PTR scancomp$11[rbp], eax
	jge	SHORT $LN101@rundevice
	mov	DWORD PTR tv513[rbp], 1
	jmp	SHORT $LN102@rundevice
$LN101@rundevice:
	mov	DWORD PTR tv513[rbp], 0
$LN102@rundevice:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv513[rbp]
	mov	BYTE PTR [rax+167], cl

; 212  : 							(scancomp >= ppu_internal.buffer_oam_read) &&
; 213  : 							(scancomp < (int)ppu_internal.buffer_oam_read + (ppuctrl.sprites_8x16 ? 16 : 8));
; 214  : 							
; 215  : 						if (ppu_internal.oam_copy && (ppu_internal.sn >= 8)) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+167]
	test	eax, eax
	je	SHORT $LN30@rundevice
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+162]
	cmp	eax, 8
	jl	SHORT $LN30@rundevice

; 216  : 							// sprite overflow.
; 217  : 							ppustatus.sprite_overflow = true;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+87], 1
$LN30@rundevice:
$LN28@rundevice:

; 218  : 						}
; 219  : 					}
; 220  : 					// copy cycles.
; 221  : 					if (ppu_internal.oam_copy) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+167]
	test	eax, eax
	je	$LN31@rundevice

; 222  : 						if ((ppu_internal.sn < 8) && !ppu_internal.oam_evald) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+162]
	cmp	eax, 8
	jge	$LN33@rundevice
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+168]
	test	eax, eax
	jne	$LN33@rundevice

; 223  : 							switch (ppu_internal.m) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+161]
	mov	BYTE PTR tv540[rbp], al
	cmp	BYTE PTR tv540[rbp], 1
	je	SHORT $LN34@rundevice
	cmp	BYTE PTR tv540[rbp], 2
	je	SHORT $LN35@rundevice
	cmp	BYTE PTR tv540[rbp], 3
	je	SHORT $LN36@rundevice
	jmp	SHORT $LN5@rundevice
$LN34@rundevice:

; 224  : 							case 0x01:	ppu_internal.secoam[ppu_internal.sn].tile = ppu_internal.buffer_oam_read;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+162]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR [rdx+165]
	mov	BYTE PTR [rcx+rax*4+116], dl

; 225  : 								break;

	jmp	SHORT $LN5@rundevice
$LN35@rundevice:

; 226  : 							case 0x02:	ppu_internal.secoam[ppu_internal.sn].attr = ppu_internal.buffer_oam_read;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+162]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR [rdx+165]
	mov	BYTE PTR [rcx+rax*4+117], dl

; 227  : 								break;

	jmp	SHORT $LN5@rundevice
$LN36@rundevice:

; 228  : 							case 0x03:	ppu_internal.secoam[ppu_internal.sn].x = ppu_internal.buffer_oam_read;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+162]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR [rdx+165]
	mov	BYTE PTR [rcx+rax*4+118], dl
$LN5@rundevice:
$LN33@rundevice:

; 229  : 								break;
; 230  : 							}
; 231  : 						}
; 232  : 						ppu_internal.m++;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+161]
	inc	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+161], al

; 233  : 						if (ppu_internal.m == 4) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+161]
	cmp	eax, 4
	jne	SHORT $LN37@rundevice

; 234  : 							// m overflows, reset to 0 and increment n.
; 235  : 							ppu_internal.m = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+161], 0

; 236  : 							ppu_internal.n++;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	inc	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+160], al

; 237  : 							if (ppu_internal.sn < 8) ppu_internal.sn++;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+162]
	cmp	eax, 8
	jge	SHORT $LN38@rundevice
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+162]
	inc	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+162], al
$LN38@rundevice:

; 238  : 							ppu_internal.oam_copy = false;	// disable copy system.

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+167], 0
$LN37@rundevice:

; 239  : 						}
; 240  : 					}
; 241  : 					else {

	jmp	SHORT $LN32@rundevice
$LN31@rundevice:

; 242  : 						// wrap n
; 243  : 						// increment n when no copy is required.
; 244  : 						ppu_internal.n++;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	inc	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+160], al
$LN32@rundevice:

; 245  : 					}
; 246  : 					// spr overflow bug?
; 247  : 					//if (ppustatus.sprite_overflow && (ppu_internal.sn < 8)) ppu_internal.n++;
; 248  : 					// wrap n
; 249  : 					if (ppu_internal.n == 64) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN39@rundevice

; 250  : 						ppu_internal.oam_evald = true;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+168], 1

; 251  : 						ppu_internal.n = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+160], 0
$LN39@rundevice:
$LN27@rundevice:
$LN25@rundevice:

; 252  : 					}
; 253  : 				}
; 254  : 			}
; 255  : 			// sprite loading.
; 256  : 			if ((cycle >= 257) && (cycle <= 320) && (scanline != 261)) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 257		; 00000101H
	jl	$LN40@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 320		; 00000140H
	jg	$LN40@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 261		; 00000105H
	je	$LN40@rundevice

; 257  : 				if (cycle == 257) ppu_internal.n = 0;

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 257		; 00000101H
	jne	SHORT $LN41@rundevice
	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+160], 0
$LN41@rundevice:

; 258  : 				byte cs = (cycle - 1) % 8;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+220]
	dec	eax
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	mov	BYTE PTR cs$12[rbp], al

; 259  : 				if (cs == 1) {

	movzx	eax, BYTE PTR cs$12[rbp]
	cmp	eax, 1
	jne	SHORT $LN42@rundevice

; 260  : 					// do garbage nametable read.
; 261  : 					ppu_internal.shiftreg_nametable = vbus.readmemory(0x2000 | (ppu_internal.v_register & 0x0FFF));

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, 4095				; 00000fffH
	bts	eax, 13
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	mov	edx, eax
	call	?readmemory@bus@@QEAAEH@Z		; bus::readmemory
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+201], al
	jmp	$LN43@rundevice
$LN42@rundevice:

; 262  : 				}
; 263  : 				else if (cs == 3) {

	movzx	eax, BYTE PTR cs$12[rbp]
	cmp	eax, 3
	jne	SHORT $LN44@rundevice

; 264  : 					// do garbage nametable read.
; 265  : 					ppu_internal.shiftreg_nametable = vbus.readmemory(0x2000 | (ppu_internal.v_register & 0x0FFF));

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, 4095				; 00000fffH
	bts	eax, 13
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	mov	edx, eax
	call	?readmemory@bus@@QEAAEH@Z		; bus::readmemory
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+201], al

; 266  : 					ppu_internal.shiftreg_spr_latch[ppu_internal.n] = ppu_internal.secoam[ppu_internal.n].attr;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+160]
	mov	rdx, QWORD PTR this$[rbp]
	mov	r8, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [r8+rax*4+117]
	mov	BYTE PTR [rdx+rcx+185], al
	jmp	$LN45@rundevice
$LN44@rundevice:

; 267  : 				}
; 268  : 				else if (cs == 5) {

	movzx	eax, BYTE PTR cs$12[rbp]
	cmp	eax, 5
	jne	$LN46@rundevice

; 269  : 					// load pattern table tile low
; 270  : 					byte ltile = ppu_internal.secoam[ppu_internal.n].tile;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax*4+116]
	mov	BYTE PTR ltile$13[rbp], al

; 271  : 					int	 ix = scanline - (ppu_internal.secoam[ppu_internal.n].y);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax*4+115]
	mov	rcx, QWORD PTR this$[rbp]
	mov	ecx, DWORD PTR [rcx+212]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ix$14[rbp], eax

; 272  : 					word pattern_address;
; 273  : 					if (ppuctrl.sprites_8x16) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+76]
	test	eax, eax
	je	SHORT $LN48@rundevice

; 274  : 						pattern_address = (ltile & 1) == 1 ? 0x1000 : 0x0000;

	movzx	eax, BYTE PTR ltile$13[rbp]
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN103@rundevice
	mov	DWORD PTR tv714[rbp], 4096		; 00001000H
	jmp	SHORT $LN104@rundevice
$LN103@rundevice:
	mov	DWORD PTR tv714[rbp], 0
$LN104@rundevice:
	movzx	eax, WORD PTR tv714[rbp]
	mov	WORD PTR pattern_address$15[rbp], ax

; 275  : 						ltile &= 0xFE;

	movzx	eax, BYTE PTR ltile$13[rbp]
	and	eax, 254				; 000000feH
	mov	BYTE PTR ltile$13[rbp], al

; 276  : 					}
; 277  : 					else {

	jmp	SHORT $LN49@rundevice
$LN48@rundevice:

; 278  : 						pattern_address = (ppuctrl.sprites_0x1000 << 12);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+74]
	shl	eax, 12
	mov	WORD PTR pattern_address$15[rbp], ax
$LN49@rundevice:

; 279  : 					}
; 280  : 					// check bit flip horiz.
; 281  : 					if ((ppu_internal.shiftreg_spr_latch[ppu_internal.n] & OAM_SPR_ATTR_FLIP_VER) == OAM_SPR_ATTR_FLIP_VER) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+185]
	and	eax, 128				; 00000080H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN50@rundevice

; 282  : 						// inverse ix.
; 283  : 						ix = ppuctrl.sprites_8x16 ? 15 - ix : 7 - ix;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+76]
	test	eax, eax
	je	SHORT $LN105@rundevice
	mov	eax, 15
	sub	eax, DWORD PTR ix$14[rbp]
	mov	DWORD PTR tv741[rbp], eax
	jmp	SHORT $LN106@rundevice
$LN105@rundevice:
	mov	eax, 7
	sub	eax, DWORD PTR ix$14[rbp]
	mov	DWORD PTR tv741[rbp], eax
$LN106@rundevice:
	mov	eax, DWORD PTR tv741[rbp]
	mov	DWORD PTR ix$14[rbp], eax
$LN50@rundevice:

; 284  : 					}
; 285  : 					if (ix > 7) pattern_address += 8;

	cmp	DWORD PTR ix$14[rbp], 7
	jle	SHORT $LN51@rundevice
	movzx	eax, WORD PTR pattern_address$15[rbp]
	add	eax, 8
	mov	WORD PTR pattern_address$15[rbp], ax
$LN51@rundevice:

; 286  : 					pattern_address += (ltile << 4) + ix;

	movzx	eax, BYTE PTR ltile$13[rbp]
	shl	eax, 4
	add	eax, DWORD PTR ix$14[rbp]
	movzx	ecx, WORD PTR pattern_address$15[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	WORD PTR pattern_address$15[rbp], ax

; 287  : 					ppu_internal.shiftreg_spr_pattern_lo[ppu_internal.n] = vbus.readmemory(pattern_address);

	movzx	eax, WORD PTR pattern_address$15[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	mov	edx, eax
	call	?readmemory@bus@@QEAAEH@Z		; bus::readmemory
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+160]
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+169], al

; 288  : 					ppu_internal.shiftreg_spr_counter[ppu_internal.n] = ppu_internal.secoam[ppu_internal.n].x;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+160]
	mov	rdx, QWORD PTR this$[rbp]
	mov	r8, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [r8+rax*4+118]
	mov	BYTE PTR [rdx+rcx+193], al
	jmp	$LN47@rundevice
$LN46@rundevice:

; 289  : 				}
; 290  : 				else if (cs == 7) {

	movzx	eax, BYTE PTR cs$12[rbp]
	cmp	eax, 7
	jne	$LN52@rundevice

; 291  : 					// load pattern table tile high
; 292  : 					byte ltile = ppu_internal.secoam[ppu_internal.n].tile;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax*4+116]
	mov	BYTE PTR ltile$16[rbp], al

; 293  : 					int	 ix = scanline - (ppu_internal.secoam[ppu_internal.n].y);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax*4+115]
	mov	rcx, QWORD PTR this$[rbp]
	mov	ecx, DWORD PTR [rcx+212]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ix$17[rbp], eax

; 294  : 					word pattern_address;
; 295  : 					if (ppuctrl.sprites_8x16) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+76]
	test	eax, eax
	je	SHORT $LN53@rundevice

; 296  : 						pattern_address = (ltile & 1) == 1 ? 0x1000 : 0x0000;

	movzx	eax, BYTE PTR ltile$16[rbp]
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN107@rundevice
	mov	DWORD PTR tv812[rbp], 4096		; 00001000H
	jmp	SHORT $LN108@rundevice
$LN107@rundevice:
	mov	DWORD PTR tv812[rbp], 0
$LN108@rundevice:
	movzx	eax, WORD PTR tv812[rbp]
	mov	WORD PTR pattern_address$18[rbp], ax

; 297  : 						ltile &= 0xFE;

	movzx	eax, BYTE PTR ltile$16[rbp]
	and	eax, 254				; 000000feH
	mov	BYTE PTR ltile$16[rbp], al

; 298  : 					}
; 299  : 					else {

	jmp	SHORT $LN54@rundevice
$LN53@rundevice:

; 300  : 						pattern_address = (ppuctrl.sprites_0x1000 << 12);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+74]
	shl	eax, 12
	mov	WORD PTR pattern_address$18[rbp], ax
$LN54@rundevice:

; 301  : 					}
; 302  : 					// check bit flip horiz.
; 303  : 					if ((ppu_internal.shiftreg_spr_latch[ppu_internal.n] & OAM_SPR_ATTR_FLIP_VER) == OAM_SPR_ATTR_FLIP_VER) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+185]
	and	eax, 128				; 00000080H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN55@rundevice

; 304  : 						// inverse ix.
; 305  : 						ix = ppuctrl.sprites_8x16 ? 15 - ix : 7 - ix;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+76]
	test	eax, eax
	je	SHORT $LN109@rundevice
	mov	eax, 15
	sub	eax, DWORD PTR ix$17[rbp]
	mov	DWORD PTR tv839[rbp], eax
	jmp	SHORT $LN110@rundevice
$LN109@rundevice:
	mov	eax, 7
	sub	eax, DWORD PTR ix$17[rbp]
	mov	DWORD PTR tv839[rbp], eax
$LN110@rundevice:
	mov	eax, DWORD PTR tv839[rbp]
	mov	DWORD PTR ix$17[rbp], eax
$LN55@rundevice:

; 306  : 					}					
; 307  : 					if (ix > 7) pattern_address += 8;

	cmp	DWORD PTR ix$17[rbp], 7
	jle	SHORT $LN56@rundevice
	movzx	eax, WORD PTR pattern_address$18[rbp]
	add	eax, 8
	mov	WORD PTR pattern_address$18[rbp], ax
$LN56@rundevice:

; 308  : 					pattern_address += (ltile << 4) + ix;

	movzx	eax, BYTE PTR ltile$16[rbp]
	shl	eax, 4
	add	eax, DWORD PTR ix$17[rbp]
	movzx	ecx, WORD PTR pattern_address$18[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	WORD PTR pattern_address$18[rbp], ax

; 309  : 					ppu_internal.shiftreg_spr_pattern_hi[ppu_internal.n] = vbus.readmemory(pattern_address + 8);

	movzx	eax, WORD PTR pattern_address$18[rbp]
	add	eax, 8
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	mov	edx, eax
	call	?readmemory@bus@@QEAAEH@Z		; bus::readmemory
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+160]
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+177], al

; 310  : 					ppu_internal.shiftreg_spr_counter[ppu_internal.n] = ppu_internal.secoam[ppu_internal.n].x;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+160]
	mov	rdx, QWORD PTR this$[rbp]
	mov	r8, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [r8+rax*4+118]
	mov	BYTE PTR [rdx+rcx+193], al

; 311  : 					ppu_internal.n++;	// eval to next sprite in seconday oam. this will never go over 7, because eval will stop earlier.

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+160]
	inc	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+160], al
$LN52@rundevice:
$LN47@rundevice:
$LN45@rundevice:
$LN43@rundevice:
$LN40@rundevice:

; 312  : 				}
; 313  : 			}
; 314  : 			// addressing cycle.
; 315  : 			if (cycle == 257) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 257		; 00000101H
	jne	SHORT $LN57@rundevice

; 316  : 				ppu_internal.v_register = (ppu_internal.v_register & ~0x041F) | (ppu_internal.t_register & 0x041F);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, -1056				; fffffffffffffbe0H
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+100]
	and	ecx, 1055				; 0000041fH
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax
$LN57@rundevice:

; 317  : 			}
; 318  : 			// loopy_v cycle (hori) @ 257
; 319  : 			//std::cout << std::dec << cycle << ", ";
; 320  : 			if (cycle == 256) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 256		; 00000100H
	jne	$LN58@rundevice

; 321  : 				if ((ppu_internal.v_register & 0x7000) != 0x7000) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, 28672				; 00007000H
	cmp	eax, 28672				; 00007000H
	je	SHORT $LN59@rundevice

; 322  : 					ppu_internal.v_register += 0x1000;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	add	eax, 4096				; 00001000H
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax

; 323  : 				}
; 324  : 				else {

	jmp	$LN60@rundevice
$LN59@rundevice:

; 325  : 					ppu_internal.v_register &= ~0x7000;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, -28673				; ffffffffffff8fffH
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax

; 326  : 					int y = ((ppu_internal.v_register & 0x03E0) >> 5);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, 992				; 000003e0H
	sar	eax, 5
	mov	DWORD PTR y$19[rbp], eax

; 327  : 					if (y == 29) {

	cmp	DWORD PTR y$19[rbp], 29
	jne	SHORT $LN61@rundevice

; 328  : 						y = 0;

	mov	DWORD PTR y$19[rbp], 0

; 329  : 						ppu_internal.v_register ^= 0x0800;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	btc	eax, 11
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax
	jmp	SHORT $LN62@rundevice
$LN61@rundevice:

; 330  : 					}
; 331  : 					else if (y == 31) {

	cmp	DWORD PTR y$19[rbp], 31
	jne	SHORT $LN63@rundevice

; 332  : 						y = 0;

	mov	DWORD PTR y$19[rbp], 0

; 333  : 					}
; 334  : 					else {

	jmp	SHORT $LN64@rundevice
$LN63@rundevice:

; 335  : 						y++;

	mov	eax, DWORD PTR y$19[rbp]
	inc	eax
	mov	DWORD PTR y$19[rbp], eax
$LN64@rundevice:
$LN62@rundevice:

; 336  : 					}
; 337  : 					ppu_internal.v_register = (ppu_internal.v_register & ~0x03E0) | (y << 5);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, -993				; fffffffffffffc1fH
	mov	ecx, DWORD PTR y$19[rbp]
	shl	ecx, 5
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax
$LN60@rundevice:
$LN58@rundevice:
$LN10@rundevice:

; 338  : 				}
; 339  : 			}
; 340  : 		}
; 341  : 		// BG/SPR rendering cycles.
; 342  : 		if ((scanline >= 0) && (scanline <= 239)) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 0
	jl	$LN65@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 239		; 000000efH
	jg	$LN65@rundevice

; 343  : 			if ((cycle >= 0) && (cycle <= 259)) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 0
	jl	$LN66@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 259		; 00000103H
	jg	$LN66@rundevice

; 344  : 				if (ppumask.showspr) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+83]
	test	eax, eax
	je	$LN67@rundevice

; 345  : 					// decrement counters.
; 346  : 					for (int i = 0; i < 8; i++) {

	mov	DWORD PTR i$20[rbp], 0
	jmp	SHORT $LN9@rundevice
$LN7@rundevice:
	mov	eax, DWORD PTR i$20[rbp]
	inc	eax
	mov	DWORD PTR i$20[rbp], eax
$LN9@rundevice:
	cmp	DWORD PTR i$20[rbp], 8
	jge	$LN8@rundevice

; 347  : 						// check if count is zero then render the pattern buffers.
; 348  : 						if (ppu_internal.shiftreg_spr_counter[i] == 0) {

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+193]
	test	eax, eax
	jne	$LN68@rundevice

; 349  : 							// we can get the pixel two ways depending on OAM_SPR_ATTR_FLIP_VER
; 350  : 							byte pix = 0;

	mov	BYTE PTR pix$21[rbp], 0

; 351  : 							if ((ppu_internal.shiftreg_spr_latch[i] & OAM_SPR_ATTR_FLIP_HOR) == OAM_SPR_ATTR_FLIP_HOR) {

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+185]
	and	eax, 64					; 00000040H
	cmp	eax, 64					; 00000040H
	jne	$LN69@rundevice

; 352  : 								// flipped.
; 353  : 								pix = ppu_internal.shiftreg_spr_pattern_lo[i] & 0x01;

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+169]
	and	eax, 1
	mov	BYTE PTR pix$21[rbp], al

; 354  : 								pix |= (ppu_internal.shiftreg_spr_pattern_hi[i] & 0x01) << 1;

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+177]
	and	eax, 1
	shl	eax, 1
	movzx	ecx, BYTE PTR pix$21[rbp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR pix$21[rbp], al

; 355  : 								ppu_internal.shiftreg_spr_pattern_lo[i] >>= 1;

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+169]
	shr	al, 1
	movsxd	rcx, DWORD PTR i$20[rbp]
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+169], al

; 356  : 								ppu_internal.shiftreg_spr_pattern_hi[i] >>= 1;

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+177]
	shr	al, 1
	movsxd	rcx, DWORD PTR i$20[rbp]
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+177], al

; 357  : 							}
; 358  : 							else {

	jmp	$LN70@rundevice
$LN69@rundevice:

; 359  : 								// normal.
; 360  : 								pix = (ppu_internal.shiftreg_spr_pattern_lo[i] & 0x80) >> 7;

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+169]
	and	eax, 128				; 00000080H
	sar	eax, 7
	mov	BYTE PTR pix$21[rbp], al

; 361  : 								pix |= (ppu_internal.shiftreg_spr_pattern_hi[i] & 0x80) >> 6;

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+177]
	and	eax, 128				; 00000080H
	sar	eax, 6
	movzx	ecx, BYTE PTR pix$21[rbp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR pix$21[rbp], al

; 362  : 								ppu_internal.shiftreg_spr_pattern_lo[i] <<= 1;

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+169]
	shl	al, 1
	movsxd	rcx, DWORD PTR i$20[rbp]
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+169], al

; 363  : 								ppu_internal.shiftreg_spr_pattern_hi[i] <<= 1;

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+177]
	shl	al, 1
	movsxd	rcx, DWORD PTR i$20[rbp]
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+177], al
$LN70@rundevice:

; 364  : 							}
; 365  : 
; 366  : 							// get pixel color.
; 367  : 							byte spr_palette = (ppu_internal.shiftreg_spr_latch[i] & OAM_SPR_ATTR_PALETTE);

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+185]
	and	eax, 3
	mov	BYTE PTR spr_palette$22[rbp], al

; 368  : 							if (pix > 0) {

	movzx	eax, BYTE PTR pix$21[rbp]
	test	eax, eax
	jle	SHORT $LN71@rundevice

; 369  : 								ppu_internal.spr_pix = pix;

	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR pix$21[rbp]
	mov	BYTE PTR [rax+163], cl

; 370  : 								ppu_internal.spr_pix_pal = vpal.read(0, 0x10 | spr_palette << 2 | pix);

	movzx	eax, BYTE PTR spr_palette$22[rbp]
	shl	eax, 2
	or	eax, 16
	movzx	ecx, BYTE PTR pix$21[rbp]
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 288				; 00000120H
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+288]
	mov	QWORD PTR tv1417[rbp], rdx
	mov	r8d, eax
	xor	edx, edx
	mov	rax, QWORD PTR tv1417[rbp]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+164], al
$LN71@rundevice:
$LN68@rundevice:

; 371  : 							}
; 372  : 						}
; 373  : 						// decrement counter register.
; 374  : 						if (ppu_internal.shiftreg_spr_counter[i] < 255)

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+193]
	cmp	eax, 255				; 000000ffH
	jge	SHORT $LN72@rundevice

; 375  : 							ppu_internal.shiftreg_spr_counter[i] = ppu_internal.shiftreg_spr_counter[i] > 0 ? ppu_internal.shiftreg_spr_counter[i] - 1 : 0;

	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+193]
	test	eax, eax
	jle	SHORT $LN111@rundevice
	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+193]
	dec	eax
	mov	DWORD PTR tv1116[rbp], eax
	jmp	SHORT $LN112@rundevice
$LN111@rundevice:
	mov	DWORD PTR tv1116[rbp], 0
$LN112@rundevice:
	movsxd	rax, DWORD PTR i$20[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR tv1116[rbp]
	mov	BYTE PTR [rcx+rax+193], dl
$LN72@rundevice:

; 376  : 					}

	jmp	$LN7@rundevice
$LN8@rundevice:
$LN67@rundevice:

; 377  : 				}
; 378  : 				if (ppumask.showbg) {				

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+82]
	test	eax, eax
	je	$LN73@rundevice

; 379  : 					// get the pixel.
; 380  : 					word pix_mux = 0x8000 >> ppu_internal.x_shift;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+97]
	mov	ecx, 32768				; 00008000H
	mov	DWORD PTR tv1895[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv1895[rbp]
	sar	eax, cl
	mov	WORD PTR pix_mux$23[rbp], ax

; 381  : 					byte palentry = (((ppu_internal.shiftregs_pattern[1] & pix_mux) > 0) << 1) |

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+106]
	movzx	ecx, WORD PTR pix_mux$23[rbp]
	and	eax, ecx
	test	eax, eax
	jle	SHORT $LN113@rundevice
	mov	DWORD PTR tv1135[rbp], 1
	jmp	SHORT $LN114@rundevice
$LN113@rundevice:
	mov	DWORD PTR tv1135[rbp], 0
$LN114@rundevice:
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+106]
	movzx	ecx, WORD PTR pix_mux$23[rbp]
	and	eax, ecx
	test	eax, eax
	jle	SHORT $LN115@rundevice
	mov	DWORD PTR tv1145[rbp], 1
	jmp	SHORT $LN116@rundevice
$LN115@rundevice:
	mov	DWORD PTR tv1145[rbp], 0
$LN116@rundevice:
	mov	eax, DWORD PTR tv1135[rbp]
	shl	eax, 1
	or	eax, DWORD PTR tv1145[rbp]
	mov	BYTE PTR palentry$24[rbp], al

; 382  : 						((ppu_internal.shiftregs_pattern[0] & pix_mux) > 0);
; 383  : 
; 384  : 					byte color = (((ppu_internal.shiftreg_attribute[1] & pix_mux) > 0) << 1) |

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+110]
	movzx	ecx, WORD PTR pix_mux$23[rbp]
	and	eax, ecx
	test	eax, eax
	jle	SHORT $LN117@rundevice
	mov	DWORD PTR tv1156[rbp], 1
	jmp	SHORT $LN118@rundevice
$LN117@rundevice:
	mov	DWORD PTR tv1156[rbp], 0
$LN118@rundevice:
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+110]
	movzx	ecx, WORD PTR pix_mux$23[rbp]
	and	eax, ecx
	test	eax, eax
	jle	SHORT $LN119@rundevice
	mov	DWORD PTR tv1166[rbp], 1
	jmp	SHORT $LN120@rundevice
$LN119@rundevice:
	mov	DWORD PTR tv1166[rbp], 0
$LN120@rundevice:
	mov	eax, DWORD PTR tv1156[rbp]
	shl	eax, 1
	or	eax, DWORD PTR tv1166[rbp]
	mov	BYTE PTR color$25[rbp], al

; 385  : 						((ppu_internal.shiftreg_attribute[0] & pix_mux) > 0);
; 386  : 					
; 387  : 					color <<= 2;

	movzx	eax, BYTE PTR color$25[rbp]
	shl	al, 2
	mov	BYTE PTR color$25[rbp], al

; 388  : 					
; 389  : 
; 390  : 					// convert color from the palette entry!
; 391  : 					//color = vbus.readmemory ((color | 0x3F00) | palentry);
; 392  : 					// no need for full bus emulation on color data.
; 393  : 					color = vpal.read(0, color | palentry);	// addr = 0x000 (vpal ignores that anyway)

	movzx	eax, BYTE PTR color$25[rbp]
	movzx	ecx, BYTE PTR palentry$24[rbp]
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 288				; 00000120H
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+288]
	mov	QWORD PTR tv1416[rbp], rdx
	mov	r8d, eax
	xor	edx, edx
	mov	rax, QWORD PTR tv1416[rbp]
	call	QWORD PTR [rax+32]
	mov	BYTE PTR color$25[rbp], al

; 394  : 
; 395  : 					// shift the registers.
; 396  : 					ppu_internal.shiftregs_pattern[0] <<= 1;

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+106]
	shl	ax, 1
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+106], ax

; 397  : 					ppu_internal.shiftregs_pattern[1] <<= 1;

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+106]
	shl	ax, 1
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+106], ax

; 398  : 					ppu_internal.shiftreg_attribute[0] <<= 1;

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+110]
	shl	ax, 1
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+110], ax

; 399  : 					ppu_internal.shiftreg_attribute[1] <<= 1;

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+110]
	shl	ax, 1
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+110], ax

; 400  : 
; 401  : 					// draw to framebuffer?
; 402  : 					if (beam<256) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+216], 256		; 00000100H
	jge	$LN75@rundevice

; 403  : 						framebuffer[scanline << 8 | beam] = color; // (palentry << 4) | (palentry << 4) << 8;

	movzx	eax, BYTE PTR color$25[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	mov	ecx, DWORD PTR [rcx+212]
	shl	ecx, 8
	mov	rdx, QWORD PTR this$[rbp]
	or	ecx, DWORD PTR [rdx+216]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+224]
	mov	WORD PTR [rdx+rcx*2], ax

; 404  : 						framebuffer[scanline << 8 | beam] |= (ppumask.emp_blu ? 0x0100 : 0) |

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+86]
	test	eax, eax
	je	SHORT $LN121@rundevice
	mov	DWORD PTR tv1248[rbp], 256		; 00000100H
	jmp	SHORT $LN122@rundevice
$LN121@rundevice:
	mov	DWORD PTR tv1248[rbp], 0
$LN122@rundevice:
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+85]
	test	eax, eax
	je	SHORT $LN123@rundevice
	mov	DWORD PTR tv1253[rbp], 512		; 00000200H
	jmp	SHORT $LN124@rundevice
$LN123@rundevice:
	mov	DWORD PTR tv1253[rbp], 0
$LN124@rundevice:
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+84]
	test	eax, eax
	je	SHORT $LN125@rundevice
	mov	DWORD PTR tv1259[rbp], 1024		; 00000400H
	jmp	SHORT $LN126@rundevice
$LN125@rundevice:
	mov	DWORD PTR tv1259[rbp], 0
$LN126@rundevice:
	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+212]
	shl	eax, 8
	mov	rcx, QWORD PTR this$[rbp]
	or	eax, DWORD PTR [rcx+216]
	cdqe
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+224]
	mov	edx, DWORD PTR tv1253[rbp]
	mov	r8d, DWORD PTR tv1248[rbp]
	or	r8d, edx
	mov	edx, r8d
	or	edx, DWORD PTR tv1259[rbp]
	movzx	eax, WORD PTR [rcx+rax*2]
	or	eax, edx
	mov	rcx, QWORD PTR this$[rbp]
	mov	ecx, DWORD PTR [rcx+212]
	shl	ecx, 8
	mov	rdx, QWORD PTR this$[rbp]
	or	ecx, DWORD PTR [rdx+216]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+224]
	mov	WORD PTR [rdx+rcx*2], ax

; 405  : 							(ppumask.emp_grn ? 0x0200 : 0) |
; 406  : 							(ppumask.emp_red ? 0x0400 : 0);
; 407  : 
; 408  : 						// spr_pix>0 just render for now.
; 409  : 						if (ppu_internal.spr_pix > 0) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+163]
	test	eax, eax
	jle	SHORT $LN76@rundevice

; 410  : 							framebuffer[scanline << 8 | beam] = ppu_internal.spr_pix_pal;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+164]
	mov	rcx, QWORD PTR this$[rbp]
	mov	ecx, DWORD PTR [rcx+212]
	shl	ecx, 8
	mov	rdx, QWORD PTR this$[rbp]
	or	ecx, DWORD PTR [rdx+216]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+224]
	mov	WORD PTR [rdx+rcx*2], ax

; 411  : 							ppu_internal.spr_pix = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+163], 0
$LN76@rundevice:
$LN75@rundevice:

; 412  : 						}						
; 413  : 					}
; 414  : 				}

	jmp	SHORT $LN74@rundevice
$LN73@rundevice:

; 415  : 				else framebuffer[scanline << 8 | beam] = vram.read(0x00, 0x3F00);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 368				; 00000170H
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+368]
	mov	QWORD PTR tv1411[rbp], rcx
	mov	r8d, 16128				; 00003f00H
	xor	edx, edx
	mov	rcx, rax
	mov	rax, QWORD PTR tv1411[rbp]
	call	QWORD PTR [rax+32]
	movzx	eax, al
	mov	rcx, QWORD PTR this$[rbp]
	mov	ecx, DWORD PTR [rcx+212]
	shl	ecx, 8
	mov	rdx, QWORD PTR this$[rbp]
	or	ecx, DWORD PTR [rdx+216]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rdx+224]
	mov	WORD PTR [rdx+rcx*2], ax
$LN74@rundevice:

; 416  : 				beam++;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+216]
	inc	eax
	mov	rcx, QWORD PTR this$[rbp]
	mov	DWORD PTR [rcx+216], eax
$LN66@rundevice:
$LN65@rundevice:

; 417  : 			}
; 418  : 		}
; 419  : 		// flags and nmi.
; 420  : 		if ((scanline == 241) && (cycle == 1)) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 241		; 000000f1H
	jne	SHORT $LN77@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 1
	jne	SHORT $LN77@rundevice

; 421  : 			// set vblank flag and raise NMI if enabled.
; 422  : 			ppustatus.vblank = true;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+89], 1

; 423  : 			if (ppuctrl.do_nmi) nmi_enable = true;	// nmi enabled gets automaticly pulled up by bus device.

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+78]
	test	eax, eax
	je	SHORT $LN78@rundevice
	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+21], 1
$LN78@rundevice:
$LN77@rundevice:

; 424  : 		}
; 425  : 
; 426  : 		if (scanline == 261) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 261		; 00000105H
	jne	$LN79@rundevice

; 427  : 			if (cycle == 1) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 1
	jne	SHORT $LN80@rundevice

; 428  : 				// reset flags.
; 429  : 				ppustatus.vblank = false;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+89], 0

; 430  : 				ppustatus.sprite_0_hit = false;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+88], 0

; 431  : 				ppustatus.sprite_overflow = false;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+87], 0
$LN80@rundevice:

; 432  : 			}
; 433  : 			if ((cycle >= 280) && (cycle <= 304)) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 280		; 00000118H
	jl	SHORT $LN81@rundevice
	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 304		; 00000130H
	jg	SHORT $LN81@rundevice

; 434  : 				// reload v register from parts of the t register.
; 435  : 				if (ppumask.showbg || ppumask.showspr) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+82]
	test	eax, eax
	jne	SHORT $LN83@rundevice
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+83]
	test	eax, eax
	je	SHORT $LN82@rundevice
$LN83@rundevice:

; 436  : 					ppu_internal.v_register = (ppu_internal.v_register & ~0x7BE0) | (ppu_internal.t_register & 0x7BE0);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	and	eax, -31713				; ffffffffffff841fH
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+100]
	and	ecx, 31712				; 00007be0H
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax
$LN82@rundevice:
$LN81@rundevice:
$LN79@rundevice:

; 437  : 				}
; 438  : 			}
; 439  : 		}
; 440  : 
; 441  : 		// Scanline..
; 442  : 		if (cycle == 339) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 339		; 00000153H
	jne	$LN84@rundevice

; 443  : 			scanline++;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+212]
	inc	eax
	mov	rcx, QWORD PTR this$[rbp]
	mov	DWORD PTR [rcx+212], eax

; 444  : 			if (scanline == 30) ppustatus.sprite_0_hit = true;	// fake it for now.

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 30
	jne	SHORT $LN85@rundevice
	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+88], 1
$LN85@rundevice:

; 445  : 			beam = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+216], 0

; 446  : 			// framebuffer done.
; 447  : 			if (scanline == 240) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 240		; 000000f0H
	jne	SHORT $LN86@rundevice

; 448  : 				frameready = true;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+232], 1
$LN86@rundevice:

; 449  : 			}
; 450  : 			if (scanline == 262) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+212], 262		; 00000106H
	jne	SHORT $LN87@rundevice

; 451  : 				scanline = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+212], 0

; 452  : 				if (ppu_internal.odd_even_frame) cycle = 340;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+202]
	test	eax, eax
	je	SHORT $LN88@rundevice
	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+220], 340		; 00000154H
$LN88@rundevice:

; 453  : 				ppu_internal.odd_even_frame = !ppu_internal.odd_even_frame;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+202]
	test	eax, eax
	jne	SHORT $LN127@rundevice
	mov	DWORD PTR tv1397[rbp], 1
	jmp	SHORT $LN128@rundevice
$LN127@rundevice:
	mov	DWORD PTR tv1397[rbp], 0
$LN128@rundevice:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv1397[rbp]
	mov	BYTE PTR [rax+202], cl
$LN87@rundevice:
$LN84@rundevice:

; 454  : 			}
; 455  : 		}
; 456  : 		cycle++; 

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+220]
	inc	eax
	mov	rcx, QWORD PTR this$[rbp]
	mov	DWORD PTR [rcx+220], eax

; 457  : 		if (cycle == 341) {			

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+220], 341		; 00000155H
	jne	SHORT $LN89@rundevice

; 458  : 			cycle = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+220], 0
$LN89@rundevice:

; 459  : 		}
; 460  : 	}

	jmp	$LN2@rundevice
$LN3@rundevice:

; 461  : 	return ticks;	// assume ticks in = ticks out.

	mov	eax, DWORD PTR ticks$[rbp]

; 462  : }

	lea	rsp, QWORD PTR [rbp+1208]
	pop	rdi
	pop	rbp
	ret	0
?rundevice@ppu@@UEAAHH@Z ENDP				; ppu::rundevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?write@ppu@@UEAAXHHE@Z
_TEXT	SEGMENT
buf$1 = 8
tv353 = 212
tv337 = 212
tv288 = 212
tv212 = 212
tv205 = 212
tv198 = 212
tv191 = 212
tv184 = 212
tv177 = 212
tv170 = 212
tv163 = 212
tv155 = 212
tv148 = 212
tv141 = 212
tv134 = 212
tv95 = 212
tv88 = 212
this$ = 256
addr$ = 264
addr_from_base$ = 272
data$ = 280
?write@ppu@@UEAAXHHE@Z PROC				; ppu::write, COMDAT

; 70   : void	ppu::write(int addr, int addr_from_base, byte data) {

$LN48:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 71   : 	// update latch
; 72   : 	latch = data;

	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR data$[rbp]
	mov	BYTE PTR [rax+208], cl

; 73   : 	// registers.
; 74   : 	if (addr_from_base == PPU_PPUCTRL_PORT) {

	cmp	DWORD PTR addr_from_base$[rbp], 0
	jne	$LN2@write

; 75   : 		ppu_internal.t_register &= ~0xC00;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+100]
	and	eax, -3073				; fffffffffffff3ffH
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax

; 76   : 		ppu_internal.t_register |= (data & PPU_BASENAMETABLE) << 10;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 3
	shl	eax, 10
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+100]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax

; 77   : 		ppuctrl.bg_0x1000 = (data & PPU_BG_TABLE_0X1000) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 16
	test	eax, eax
	jle	SHORT $LN14@write
	mov	DWORD PTR tv88[rbp], 1
	jmp	SHORT $LN15@write
$LN14@write:
	mov	DWORD PTR tv88[rbp], 0
$LN15@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv88[rbp]
	mov	BYTE PTR [rax+75], cl

; 78   : 		ppuctrl.sprites_0x1000 = (data & PPU_SPRITE_TABLE_0X1000) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 8
	test	eax, eax
	jle	SHORT $LN16@write
	mov	DWORD PTR tv95[rbp], 1
	jmp	SHORT $LN17@write
$LN16@write:
	mov	DWORD PTR tv95[rbp], 0
$LN17@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv95[rbp]
	mov	BYTE PTR [rax+74], cl

; 79   : 		ppuctrl.do_nmi = (data & PPU_DO_NMI) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jle	SHORT $LN18@write
	mov	DWORD PTR tv134[rbp], 1
	jmp	SHORT $LN19@write
$LN18@write:
	mov	DWORD PTR tv134[rbp], 0
$LN19@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv134[rbp]
	mov	BYTE PTR [rax+78], cl

; 80   : 		ppuctrl.increment_32_bytes = (data & PPU_VRAM_INCREMENT_32BYTES) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 4
	test	eax, eax
	jle	SHORT $LN20@write
	mov	DWORD PTR tv141[rbp], 1
	jmp	SHORT $LN21@write
$LN20@write:
	mov	DWORD PTR tv141[rbp], 0
$LN21@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv141[rbp]
	mov	BYTE PTR [rax+73], cl

; 81   : 		ppuctrl.master_mode = (data & PPU_MASTER_MODE) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jle	SHORT $LN22@write
	mov	DWORD PTR tv148[rbp], 1
	jmp	SHORT $LN23@write
$LN22@write:
	mov	DWORD PTR tv148[rbp], 0
$LN23@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv148[rbp]
	mov	BYTE PTR [rax+77], cl

; 82   : 		ppuctrl.sprites_8x16 = (data & PPU_SPRITE_8X16) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jle	SHORT $LN24@write
	mov	DWORD PTR tv155[rbp], 1
	jmp	SHORT $LN25@write
$LN24@write:
	mov	DWORD PTR tv155[rbp], 0
$LN25@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv155[rbp]
	mov	BYTE PTR [rax+76], cl
$LN2@write:

; 83   : 	}
; 84   : 	if (addr_from_base == PPU_PPUMASK_PORT) {

	cmp	DWORD PTR addr_from_base$[rbp], 1
	jne	$LN3@write

; 85   : 		ppumask.bg8lt = (data & PPU_BG_L8P) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 2
	test	eax, eax
	jle	SHORT $LN26@write
	mov	DWORD PTR tv163[rbp], 1
	jmp	SHORT $LN27@write
$LN26@write:
	mov	DWORD PTR tv163[rbp], 0
$LN27@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv163[rbp]
	mov	BYTE PTR [rax+80], cl

; 86   : 		ppumask.emp_blu = (data & PPU_EMP_BLUE) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jle	SHORT $LN28@write
	mov	DWORD PTR tv170[rbp], 1
	jmp	SHORT $LN29@write
$LN28@write:
	mov	DWORD PTR tv170[rbp], 0
$LN29@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv170[rbp]
	mov	BYTE PTR [rax+86], cl

; 87   : 		ppumask.emp_grn = (data & PPU_EMP_GREEN) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jle	SHORT $LN30@write
	mov	DWORD PTR tv177[rbp], 1
	jmp	SHORT $LN31@write
$LN30@write:
	mov	DWORD PTR tv177[rbp], 0
$LN31@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv177[rbp]
	mov	BYTE PTR [rax+85], cl

; 88   : 		ppumask.emp_red = (data & PPU_EMP_RED) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jle	SHORT $LN32@write
	mov	DWORD PTR tv184[rbp], 1
	jmp	SHORT $LN33@write
$LN32@write:
	mov	DWORD PTR tv184[rbp], 0
$LN33@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv184[rbp]
	mov	BYTE PTR [rax+84], cl

; 89   : 		ppumask.grayscale = (data & PPU_GREYSCALE) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 1
	test	eax, eax
	jle	SHORT $LN34@write
	mov	DWORD PTR tv191[rbp], 1
	jmp	SHORT $LN35@write
$LN34@write:
	mov	DWORD PTR tv191[rbp], 0
$LN35@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv191[rbp]
	mov	BYTE PTR [rax+79], cl

; 90   : 		ppumask.showbg = (data & PPU_SHOW_BG) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 8
	test	eax, eax
	jle	SHORT $LN36@write
	mov	DWORD PTR tv198[rbp], 1
	jmp	SHORT $LN37@write
$LN36@write:
	mov	DWORD PTR tv198[rbp], 0
$LN37@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv198[rbp]
	mov	BYTE PTR [rax+82], cl

; 91   : 		ppumask.showspr = (data & PPU_SHOW_SPR) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 16
	test	eax, eax
	jle	SHORT $LN38@write
	mov	DWORD PTR tv205[rbp], 1
	jmp	SHORT $LN39@write
$LN38@write:
	mov	DWORD PTR tv205[rbp], 0
$LN39@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv205[rbp]
	mov	BYTE PTR [rax+83], cl

; 92   : 		ppumask.spr8lt = (data & PPU_SPR_L8P) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 4
	test	eax, eax
	jle	SHORT $LN40@write
	mov	DWORD PTR tv212[rbp], 1
	jmp	SHORT $LN41@write
$LN40@write:
	mov	DWORD PTR tv212[rbp], 0
$LN41@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv212[rbp]
	mov	BYTE PTR [rax+81], cl
$LN3@write:

; 93   : 	}
; 94   : 	// OAMADDR register (0x03)
; 95   : 	if (addr_from_base == PPU_OAMADDR_PORT) {

	cmp	DWORD PTR addr_from_base$[rbp], 3
	jne	SHORT $LN4@write

; 96   : 		oamaddr = data;

	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR data$[rbp]
	mov	BYTE PTR [rax+704], cl
$LN4@write:

; 97   : 	}
; 98   : 	// OAMDATA register
; 99   : 	if (addr_from_base == PPU_OAMDATA_PORT) {

	cmp	DWORD PTR addr_from_base$[rbp], 4
	jne	SHORT $LN5@write

; 100  : 		char *buf = (char*)&oam;

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 448				; 000001c0H
	mov	QWORD PTR buf$1[rbp], rax

; 101  : 		buf[oamaddr++] = data;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+704]
	mov	rcx, QWORD PTR buf$1[rbp]
	movzx	edx, BYTE PTR data$[rbp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+704]
	inc	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+704], al
$LN5@write:

; 102  : 	}
; 103  : 	if (addr_from_base == PPU_SCROLL_PORT) {

	cmp	DWORD PTR addr_from_base$[rbp], 5
	jne	$LN6@write

; 104  : 		if (!ppu_internal.address_write_latch) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+96]
	test	eax, eax
	jne	SHORT $LN7@write

; 105  : 			ppu_internal.t_register &= ~0x1F;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+100]
	and	eax, -32				; ffffffffffffffe0H
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax

; 106  : 			ppu_internal.t_register |= (data & 0xF8) >> 3;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 248				; 000000f8H
	sar	eax, 3
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+100]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax

; 107  : 			ppu_internal.x_shift = data & 0x07;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 7
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+97], al

; 108  : 		}
; 109  : 		else {

	jmp	SHORT $LN8@write
$LN7@write:

; 110  : 			ppu_internal.t_register &= ~0x73E0;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+100]
	and	eax, -29665				; ffffffffffff8c1fH
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax

; 111  : 			ppu_internal.t_register |= (data & 0x07) << 12;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 7
	shl	eax, 12
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+100]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax

; 112  : 			ppu_internal.t_register |= (data & 0xF8) << 2;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 248				; 000000f8H
	shl	eax, 2
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+100]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax
$LN8@write:

; 113  : 		}
; 114  : 		ppu_internal.address_write_latch = !ppu_internal.address_write_latch;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+96]
	test	eax, eax
	jne	SHORT $LN42@write
	mov	DWORD PTR tv288[rbp], 1
	jmp	SHORT $LN43@write
$LN42@write:
	mov	DWORD PTR tv288[rbp], 0
$LN43@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv288[rbp]
	mov	BYTE PTR [rax+96], cl
$LN6@write:

; 115  : 	}
; 116  : 	if (addr_from_base == PPU_ADDRESS_PORT) {

	cmp	DWORD PTR addr_from_base$[rbp], 6
	jne	$LN9@write

; 117  : 		if (!ppu_internal.address_write_latch) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+96]
	test	eax, eax
	jne	SHORT $LN10@write

; 118  : 			ppu_internal.t_register &= ~0x7F00;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+100]
	and	eax, -32513				; ffffffffffff80ffH
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax

; 119  : 			ppu_internal.t_register |= (data & 0x3F) << 8;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 63					; 0000003fH
	shl	eax, 8
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+100]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax

; 120  : 		}
; 121  : 		else {

	jmp	SHORT $LN11@write
$LN10@write:

; 122  : 			ppu_internal.t_register &= 0xFF00;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+100]
	and	eax, 65280				; 0000ff00H
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax

; 123  : 			ppu_internal.t_register |= data;

	movzx	eax, BYTE PTR data$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+100]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+100], ax

; 124  : 			ppu_internal.v_register = ppu_internal.t_register;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+100]
	mov	WORD PTR [rax+102], cx
$LN11@write:

; 125  : 		}
; 126  : 		ppu_internal.address_write_latch = !ppu_internal.address_write_latch;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+96]
	test	eax, eax
	jne	SHORT $LN44@write
	mov	DWORD PTR tv337[rbp], 1
	jmp	SHORT $LN45@write
$LN44@write:
	mov	DWORD PTR tv337[rbp], 0
$LN45@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv337[rbp]
	mov	BYTE PTR [rax+96], cl
$LN9@write:

; 127  : 	}
; 128  : 	if (addr_from_base == PPU_DATA_PORT) {

	cmp	DWORD PTR addr_from_base$[rbp], 7
	jne	SHORT $LN12@write

; 129  : 		vbus.writememory(ppu_internal.v_register, data);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	movzx	r8d, BYTE PTR data$[rbp]
	mov	edx, eax
	call	?writememory@bus@@QEAAXHE@Z		; bus::writememory

; 130  : 		ppu_internal.v_register += ppuctrl.increment_32_bytes ? 32 : 1;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+73]
	test	eax, eax
	je	SHORT $LN46@write
	mov	DWORD PTR tv353[rbp], 32		; 00000020H
	jmp	SHORT $LN47@write
$LN46@write:
	mov	DWORD PTR tv353[rbp], 1
$LN47@write:
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	add	eax, DWORD PTR tv353[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax
$LN12@write:

; 131  : 	}
; 132  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?write@ppu@@UEAAXHHE@Z ENDP				; ppu::write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?read@ppu@@UEAAEHH@Z
_TEXT	SEGMENT
status$1 = 4
buf$2 = 40
data$3 = 68
this$ = 320
addr$ = 328
addr_from_base$ = 336
?read@ppu@@UEAAEHH@Z PROC				; ppu::read, COMDAT

; 36   : byte	ppu::read(int addr, int addr_from_base) {

$LN12:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 37   : 	// registers
; 38   : 	// PPU STATUS register
; 39   : 	if (addr_from_base == PPU_PPUSTATUS_PORT) {

	cmp	DWORD PTR addr_from_base$[rbp], 2
	jne	SHORT $LN2@read

; 40   : 		byte	status = latch & 0x1F;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+208]
	and	eax, 31
	mov	BYTE PTR status$1[rbp], al

; 41   : 		if (ppustatus.sprite_0_hit) status |= PPU_SPR_0HIT;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+88]
	test	eax, eax
	je	SHORT $LN3@read
	movzx	eax, BYTE PTR status$1[rbp]
	or	eax, 64					; 00000040H
	mov	BYTE PTR status$1[rbp], al
$LN3@read:

; 42   : 		if (ppustatus.sprite_overflow) status |= PPU_SPR_OVERFLOW;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+87]
	test	eax, eax
	je	SHORT $LN4@read
	movzx	eax, BYTE PTR status$1[rbp]
	or	eax, 32					; 00000020H
	mov	BYTE PTR status$1[rbp], al
$LN4@read:

; 43   : 		if (ppustatus.vblank) status |= PPU_VBLANK;	

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+89]
	test	eax, eax
	je	SHORT $LN5@read
	movzx	eax, BYTE PTR status$1[rbp]
	bts	eax, 7
	mov	BYTE PTR status$1[rbp], al
$LN5@read:

; 44   : 		// clear vblank status after reading PPUSTATUS_PORT (* see https://wiki.nesdev.com/w/index.php/PPU_registers @ read $2002)
; 45   : 		ppustatus.vblank = false;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+89], 0

; 46   : 		ppu_internal.address_write_latch = false;	// reset write latch for address and scroll (* see https://wiki.nesdev.com/w/index.php/PPU_registers @ read $2002)

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+96], 0

; 47   : 		return status;

	movzx	eax, BYTE PTR status$1[rbp]
	jmp	$LN1@read
$LN2@read:

; 48   : 	}
; 49   : 	// OAMDATA register
; 50   : 	if (addr_from_base == PPU_OAMDATA_PORT) {

	cmp	DWORD PTR addr_from_base$[rbp], 4
	jne	SHORT $LN6@read

; 51   : 		if (ppu_internal.oam_clearing) return 0xFF; // when clearing sec oam, reads to 2004 will return 0xFF

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+166]
	test	eax, eax
	je	SHORT $LN7@read
	mov	al, 255					; 000000ffH
	jmp	$LN1@read
$LN7@read:

; 52   : 		char *buf = (char *)&oam;

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 448				; 000001c0H
	mov	QWORD PTR buf$2[rbp], rax

; 53   : 		return buf[oamaddr]; // no increment as per write (* see https://wiki.nesdev.com/w/index.php/PPU_registers @ read $2004)

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+704]
	mov	rcx, QWORD PTR buf$2[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	jmp	$LN1@read
$LN6@read:

; 54   : 	}
; 55   : 	// READ register.
; 56   : 	if (addr_from_base == PPU_DATA_PORT) {

	cmp	DWORD PTR addr_from_base$[rbp], 7
	jne	$LN8@read

; 57   : 		byte data = prt2007buffer;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+233]
	mov	BYTE PTR data$3[rbp], al

; 58   : 		prt2007buffer = vbus.readmemory(ppu_internal.v_register);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	mov	edx, eax
	call	?readmemory@bus@@QEAAEH@Z		; bus::readmemory
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+233], al

; 59   : 		if (ppuctrl.increment_32_bytes) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+73]
	test	eax, eax
	je	SHORT $LN9@read

; 60   : 			ppu_internal.v_register += 32;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	add	eax, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax

; 61   : 		}
; 62   : 		else {

	jmp	SHORT $LN10@read
$LN9@read:

; 63   : 			ppu_internal.v_register++;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+102]
	inc	ax
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+102], ax
$LN10@read:

; 64   : 		}
; 65   : 		return data;

	movzx	eax, BYTE PTR data$3[rbp]
	jmp	SHORT $LN1@read
$LN8@read:

; 66   : 	}
; 67   : 	return 0x00;

	xor	al, al
$LN1@read:

; 68   : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
?read@ppu@@UEAAEHH@Z ENDP				; ppu::read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ??1ppu@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1ppu@@UEAA@XZ PROC					; ppu::~ppu, COMDAT

; 30   : ppu::~ppu() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	QWORD PTR $T1[rbp], -2
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7ppu@@6B@
	mov	QWORD PTR [rax], rcx

; 31   : 	vbus.removedevice_select_base(vpal.devicestart);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 240				; 000000f0H
	mov	rcx, QWORD PTR this$[rbp]
	mov	edx, DWORD PTR [rcx+332]
	mov	rcx, rax
	call	?removedevice_select_base@bus@@QEAAXH@Z	; bus::removedevice_select_base
	npad	1

; 32   : 	vbus.removedevice_select_base(vram.devicestart);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 240				; 000000f0H
	mov	rcx, QWORD PTR this$[rbp]
	mov	edx, DWORD PTR [rcx+412]
	mov	rcx, rax
	call	?removedevice_select_base@bus@@QEAAXH@Z	; bus::removedevice_select_base
	npad	1

; 33   : }

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 368				; 00000170H
	mov	rcx, rax
	call	??1ppuram@@UEAA@XZ			; ppuram::~ppuram
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 288				; 00000120H
	mov	rcx, rax
	call	??1ppu_pal_ram@@UEAA@XZ			; ppu_pal_ram::~ppu_pal_ram
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 240				; 000000f0H
	mov	rcx, rax
	call	??1bus@@QEAA@XZ				; bus::~bus
	npad	1
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	npad	1
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??1ppu@@UEAA@XZ ENDP					; ppu::~ppu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ??0ppu@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??0ppu@@QEAA@XZ PROC					; ppu::ppu, COMDAT

; 11   : ppu::ppu() : bus_device () {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	QWORD PTR $T1[rbp], -2
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR this$[rbp]
	call	??0bus_device@@QEAA@XZ			; bus_device::bus_device
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7ppu@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 240				; 000000f0H
	mov	rcx, rax
	call	??0bus@@QEAA@XZ				; bus::bus
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 288				; 00000120H
	mov	rcx, rax
	call	??0ppu_pal_ram@@QEAA@XZ			; ppu_pal_ram::ppu_pal_ram
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 368				; 00000170H
	mov	rcx, rax
	call	??0ppuram@@QEAA@XZ			; ppuram::ppuram
	npad	1

; 12   : 	strcpy_s(get_device_descriptor(), MAX_DESCRIPTOR_LENGTH, "Denver PPU Unit");

	mov	rcx, QWORD PTR this$[rbp]
	call	?get_device_descriptor@device@@QEAAPEADXZ ; device::get_device_descriptor
	lea	r8, OFFSET FLAT:??_C@_0BA@OKGNICPF@Denver?5PPU?5Unit@
	mov	edx, 128				; 00000080H
	mov	rcx, rax
	call	QWORD PTR __imp_strcpy_s

; 13   : 	devicestart = 0x2000;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+44], 8192		; 00002000H

; 14   : 	deviceend = 0x3FFF;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+48], 16383		; 00003fffH

; 15   : 	devicemask = 0x2007;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+52], 8199		; 00002007H

; 16   : 	tick_rate = 0x1;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+16], 1

; 17   : 	// make bus
; 18   : 	// Palette RAM
; 19   : 	vbus.registerdevice(&vpal);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 288				; 00000120H
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	mov	rdx, rax
	call	?registerdevice@bus@@QEAAXPEAVbus_device@@@Z ; bus::registerdevice

; 20   : 	// vram
; 21   : 	vbus.registerdevice(&vram);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 368				; 00000170H
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	mov	rdx, rax
	call	?registerdevice@bus@@QEAAXPEAVbus_device@@@Z ; bus::registerdevice

; 22   : 	// oam (internal, unbussed)
; 23   : 	// framebuffer.
; 24   : 	framebuffer = (word *)malloc(256 * 240 * 2);

	mov	ecx, 122880				; 0001e000H
	call	QWORD PTR __imp_malloc
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+224], rax

; 25   : 	scanline = -1;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+212], -1

; 26   : 	beam = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+216], 0

; 27   : 	cycle = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+220], 0

; 28   : }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??0ppu@@QEAA@XZ ENDP					; ppu::ppu
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ppu@@QEAA@XZ@4HA PROC			; `ppu::ppu'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0ppu@@QEAA@XZ@4HA ENDP			; `ppu::ppu'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$1@?0???0ppu@@QEAA@XZ@4HA PROC			; `ppu::ppu'::`1'::dtor$1
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	call	??1bus@@QEAA@XZ				; bus::~bus
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$1@?0???0ppu@@QEAA@XZ@4HA ENDP			; `ppu::ppu'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$2@?0???0ppu@@QEAA@XZ@4HA PROC			; `ppu::ppu'::`1'::dtor$2
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 288				; 00000120H
	call	??1ppu_pal_ram@@UEAA@XZ			; ppu_pal_ram::~ppu_pal_ram
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$2@?0???0ppu@@QEAA@XZ@4HA ENDP			; `ppu::ppu'::`1'::dtor$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$3@?0???0ppu@@QEAA@XZ@4HA PROC			; `ppu::ppu'::`1'::dtor$3
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 368				; 00000170H
	call	??1ppuram@@UEAA@XZ			; ppuram::~ppuram
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$3@?0???0ppu@@QEAA@XZ@4HA ENDP			; `ppu::ppu'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ppu@@QEAA@XZ@4HA PROC			; `ppu::ppu'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0ppu@@QEAA@XZ@4HA ENDP			; `ppu::ppu'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$1@?0???0ppu@@QEAA@XZ@4HA PROC			; `ppu::ppu'::`1'::dtor$1
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 240				; 000000f0H
	call	??1bus@@QEAA@XZ				; bus::~bus
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$1@?0???0ppu@@QEAA@XZ@4HA ENDP			; `ppu::ppu'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$2@?0???0ppu@@QEAA@XZ@4HA PROC			; `ppu::ppu'::`1'::dtor$2
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 288				; 00000120H
	call	??1ppu_pal_ram@@UEAA@XZ			; ppu_pal_ram::~ppu_pal_ram
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$2@?0???0ppu@@QEAA@XZ@4HA ENDP			; `ppu::ppu'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$3@?0???0ppu@@QEAA@XZ@4HA PROC			; `ppu::ppu'::`1'::dtor$3
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 368				; 00000170H
	call	??1ppuram@@UEAA@XZ			; ppuram::~ppuram
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$3@?0???0ppu@@QEAA@XZ@4HA ENDP			; `ppu::ppu'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gppu_pal_ram@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gppu_pal_ram@@UEAAPEAXI@Z PROC			; ppu_pal_ram::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1ppu_pal_ram@@UEAA@XZ			; ppu_pal_ram::~ppu_pal_ram
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 80					; 00000050H
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gppu_pal_ram@@UEAAPEAXI@Z ENDP			; ppu_pal_ram::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?write@ppu_pal_ram@@UEAAXHHE@Z
_TEXT	SEGMENT
this$ = 224
addr$ = 232
addr_from_base$ = 240
data$ = 248
?write@ppu_pal_ram@@UEAAXHHE@Z PROC			; ppu_pal_ram::write, COMDAT

; 541  : void ppu_pal_ram::write(int addr, int addr_from_base, byte data) {

$LN3:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 542  : 	ram[pal_addr_compute (addr_from_base)] = data;

	mov	rax, QWORD PTR this$[rbp]
	mov	edx, DWORD PTR addr_from_base$[rbp]
	mov	rcx, rax
	call	?pal_addr_compute@ppu_pal_ram@@AEAAHH@Z	; ppu_pal_ram::pal_addr_compute
	cdqe
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	movzx	edx, BYTE PTR data$[rbp]
	mov	BYTE PTR [rcx+rax], dl

; 543  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?write@ppu_pal_ram@@UEAAXHHE@Z ENDP			; ppu_pal_ram::write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?read@ppu_pal_ram@@UEAAEHH@Z
_TEXT	SEGMENT
this$ = 224
addr$ = 232
addr_from_base$ = 240
?read@ppu_pal_ram@@UEAAEHH@Z PROC			; ppu_pal_ram::read, COMDAT

; 545  : byte ppu_pal_ram::read(int addr, int addr_from_base) {

$LN6:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 546  : 	if (addr_from_base == 0x04) return ram[0x00];

	cmp	DWORD PTR addr_from_base$[rbp], 4
	jne	SHORT $LN2@read
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	movzx	eax, BYTE PTR [rax+rcx]
	jmp	SHORT $LN1@read
$LN2@read:

; 547  : 	if (addr_from_base == 0x08) return ram[0x00];

	cmp	DWORD PTR addr_from_base$[rbp], 8
	jne	SHORT $LN3@read
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	movzx	eax, BYTE PTR [rax+rcx]
	jmp	SHORT $LN1@read
$LN3@read:

; 548  : 	if (addr_from_base == 0x0C) return ram[0x00];

	cmp	DWORD PTR addr_from_base$[rbp], 12
	jne	SHORT $LN4@read
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	movzx	eax, BYTE PTR [rax+rcx]
	jmp	SHORT $LN1@read
$LN4@read:

; 549  : 	return ram[pal_addr_compute(addr_from_base)];	

	mov	rax, QWORD PTR this$[rbp]
	mov	edx, DWORD PTR addr_from_base$[rbp]
	mov	rcx, rax
	call	?pal_addr_compute@ppu_pal_ram@@AEAAHH@Z	; ppu_pal_ram::pal_addr_compute
	cdqe
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	movzx	eax, BYTE PTR [rcx+rax]
$LN1@read:

; 550  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?read@ppu_pal_ram@@UEAAEHH@Z ENDP			; ppu_pal_ram::read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ??1ppu_pal_ram@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1ppu_pal_ram@@UEAA@XZ PROC				; ppu_pal_ram::~ppu_pal_ram, COMDAT

; 529  : ppu_pal_ram::~ppu_pal_ram() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	QWORD PTR $T1[rbp], -2
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7ppu_pal_ram@@6B@
	mov	QWORD PTR [rax], rcx

; 530  : 	free(ram);

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax+72]
	call	QWORD PTR __imp_free
	npad	1

; 531  : }

	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	npad	1
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??1ppu_pal_ram@@UEAA@XZ ENDP				; ppu_pal_ram::~ppu_pal_ram
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ??0ppu_pal_ram@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??0ppu_pal_ram@@QEAA@XZ PROC				; ppu_pal_ram::ppu_pal_ram, COMDAT

; 521  : ppu_pal_ram::ppu_pal_ram() : bus_device() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	QWORD PTR $T1[rbp], -2
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR this$[rbp]
	call	??0bus_device@@QEAA@XZ			; bus_device::bus_device
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7ppu_pal_ram@@6B@
	mov	QWORD PTR [rax], rcx

; 522  : 	strcpy_s(get_device_descriptor(), MAX_DESCRIPTOR_LENGTH, "PPU palette RAM 32 bytes");

	mov	rcx, QWORD PTR this$[rbp]
	call	?get_device_descriptor@device@@QEAAPEADXZ ; device::get_device_descriptor
	lea	r8, OFFSET FLAT:??_C@_0BJ@GBIMAOLL@PPU?5palette?5RAM?532?5bytes@
	mov	edx, 128				; 00000080H
	mov	rcx, rax
	call	QWORD PTR __imp_strcpy_s

; 523  : 	ram = (byte *)malloc(0x20);

	mov	ecx, 32					; 00000020H
	call	QWORD PTR __imp_malloc
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+72], rax

; 524  : 	devicestart = 0x3F00;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+44], 16128		; 00003f00H

; 525  : 	deviceend = 0x3FFF;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+48], 16383		; 00003fffH

; 526  : 	devicemask = 0x3F1F;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+52], 16159		; 00003f1fH

; 527  : }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??0ppu_pal_ram@@QEAA@XZ ENDP				; ppu_pal_ram::ppu_pal_ram
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ppu_pal_ram@@QEAA@XZ@4HA PROC		; `ppu_pal_ram::ppu_pal_ram'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0ppu_pal_ram@@QEAA@XZ@4HA ENDP		; `ppu_pal_ram::ppu_pal_ram'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ppu_pal_ram@@QEAA@XZ@4HA PROC		; `ppu_pal_ram::ppu_pal_ram'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0ppu_pal_ram@@QEAA@XZ@4HA ENDP		; `ppu_pal_ram::ppu_pal_ram'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?pal_addr_compute@ppu_pal_ram@@AEAAHH@Z
_TEXT	SEGMENT
this$ = 224
addr$ = 232
?pal_addr_compute@ppu_pal_ram@@AEAAHH@Z PROC		; ppu_pal_ram::pal_addr_compute, COMDAT

; 533  : int ppu_pal_ram::pal_addr_compute(int addr) {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 534  : 	if (addr == 0x10) return 0x00;

	cmp	DWORD PTR addr$[rbp], 16
	jne	SHORT $LN2@pal_addr_c
	xor	eax, eax
	jmp	SHORT $LN1@pal_addr_c
$LN2@pal_addr_c:

; 535  : 	if (addr == 0x14) return 0x04;

	cmp	DWORD PTR addr$[rbp], 20
	jne	SHORT $LN3@pal_addr_c
	mov	eax, 4
	jmp	SHORT $LN1@pal_addr_c
$LN3@pal_addr_c:

; 536  : 	if (addr == 0x18) return 0x08;

	cmp	DWORD PTR addr$[rbp], 24
	jne	SHORT $LN4@pal_addr_c
	mov	eax, 8
	jmp	SHORT $LN1@pal_addr_c
$LN4@pal_addr_c:

; 537  : 	if (addr == 0x1C) return 0x0C;

	cmp	DWORD PTR addr$[rbp], 28
	jne	SHORT $LN5@pal_addr_c
	mov	eax, 12
	jmp	SHORT $LN1@pal_addr_c
$LN5@pal_addr_c:

; 538  : 	return addr;

	mov	eax, DWORD PTR addr$[rbp]
$LN1@pal_addr_c:

; 539  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?pal_addr_compute@ppu_pal_ram@@AEAAHH@Z ENDP		; ppu_pal_ram::pal_addr_compute
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gppuram@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gppuram@@UEAAPEAXI@Z PROC				; ppuram::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1ppuram@@UEAA@XZ			; ppuram::~ppuram
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 80					; 00000050H
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gppuram@@UEAAPEAXI@Z ENDP				; ppuram::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?write@ppuram@@UEAAXHHE@Z
_TEXT	SEGMENT
this$ = 224
addr$ = 232
addr_from_base$ = 240
data$ = 248
?write@ppuram@@UEAAXHHE@Z PROC				; ppuram::write, COMDAT

; 512  : void	ppuram::write(int addr, int addr_from_base, byte data) {

$LN3:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 513  : 	ram[addr_from_base] = data;

	movsxd	rax, DWORD PTR addr_from_base$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	movzx	edx, BYTE PTR data$[rbp]
	mov	BYTE PTR [rcx+rax], dl

; 514  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?write@ppuram@@UEAAXHHE@Z ENDP				; ppuram::write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?read@ppuram@@UEAAEHH@Z
_TEXT	SEGMENT
this$ = 224
addr$ = 232
addr_from_base$ = 240
?read@ppuram@@UEAAEHH@Z PROC				; ppuram::read, COMDAT

; 516  : byte	ppuram::read(int addr, int addr_from_base) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode

; 517  : 	return ram[addr_from_base];

	movsxd	rax, DWORD PTR addr_from_base$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	movzx	eax, BYTE PTR [rcx+rax]

; 518  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?read@ppuram@@UEAAEHH@Z ENDP				; ppuram::read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ??1ppuram@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1ppuram@@UEAA@XZ PROC					; ppuram::~ppuram, COMDAT

; 508  : ppuram::~ppuram() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	QWORD PTR $T1[rbp], -2
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7ppuram@@6B@
	mov	QWORD PTR [rax], rcx

; 509  : 	free(ram);

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax+72]
	call	QWORD PTR __imp_free
	npad	1

; 510  : }

	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	npad	1
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??1ppuram@@UEAA@XZ ENDP					; ppuram::~ppuram
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ??0ppuram@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??0ppuram@@QEAA@XZ PROC					; ppuram::ppuram, COMDAT

; 500  : ppuram::ppuram() : bus_device() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	QWORD PTR $T1[rbp], -2
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR this$[rbp]
	call	??0bus_device@@QEAA@XZ			; bus_device::bus_device
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7ppuram@@6B@
	mov	QWORD PTR [rax], rcx

; 501  : 	strcpy_s(get_device_descriptor(), MAX_DESCRIPTOR_LENGTH, "PPU mainram 2k");

	mov	rcx, QWORD PTR this$[rbp]
	call	?get_device_descriptor@device@@QEAAPEADXZ ; device::get_device_descriptor
	lea	r8, OFFSET FLAT:??_C@_0P@MFMHDPIH@PPU?5mainram?52k@
	mov	edx, 128				; 00000080H
	mov	rcx, rax
	call	QWORD PTR __imp_strcpy_s

; 502  : 	ram = (byte *)malloc(0x800);

	mov	ecx, 2048				; 00000800H
	call	QWORD PTR __imp_malloc
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+72], rax

; 503  : 	devicestart = 0x2000;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+44], 8192		; 00002000H

; 504  : 	deviceend = 0x3EFF;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+48], 16127		; 00003effH

; 505  : 	devicemask = 0x27FF;	 // per default ppu has 2k of RAM mirrored to 4k of address-space.

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+52], 10239		; 000027ffH

; 506  : }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??0ppuram@@QEAA@XZ ENDP					; ppuram::ppuram
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ppuram@@QEAA@XZ@4HA PROC			; `ppuram::ppuram'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0ppuram@@QEAA@XZ@4HA ENDP			; `ppuram::ppuram'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ppuram@@QEAA@XZ@4HA PROC			; `ppuram::ppuram'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0ppuram@@QEAA@XZ@4HA ENDP			; `ppuram::ppuram'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 224
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__5DCDE773_ppu@cpp
	call	__CheckForDebuggerJustMyCode
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END

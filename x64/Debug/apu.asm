; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27050.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__FF24E80D_stdafx@h DB 01H
__84F95A01_denveremu@pch DB 01H
__122CF1B0_xstddef DB 01H
__FB7583FD_xstring DB 01H
__9C647009_apu@cpp DB 01H
__F007F164_stdexcept DB 01H
__C334353D_xatomic0@h DB 01H
__1CE3C767_xmemory0 DB 01H
__CDB00636_xutility DB 01H
__7E39D651_iosfwd DB 01H
__BEFE0DB4_string@h DB 01H
__1F77EA16_corecrt_memory@h DB 01H
__7949CB39_exception DB 01H
__9BB4E194_vcruntime_exception@h DB 01H
__ACA0BEE6_malloc@h DB 01H
__5ECFF36E_type_traits DB 01H
__B2D003D7_limits DB 01H
__3736D25A_xtgmath@h DB 01H
__824D367B_cmath DB 01H
__D23EE329_cstdlib DB 01H
__AF9067BE_corecrt_math@h DB 01H
__388D9910_stdlib@h DB 01H
__6BC0FD35_vcruntime_new@h DB 01H
msvcjmc	ENDS
CONST	SEGMENT
?duty_cycle_osc@@3QBEB DB 01H				; duty_cycle_osc
	DB	03H
	DB	0fH
	DB	0fcH
CONST	ENDS
PUBLIC	?update_timers@pulse_generator@@QEAAXXZ		; pulse_generator::update_timers
PUBLIC	?half_clock@pulse_generator@@QEAAXXZ		; pulse_generator::half_clock
PUBLIC	?quarter_clock@pulse_generator@@QEAAXXZ		; pulse_generator::quarter_clock
PUBLIC	?sweep@pulse_generator@@QEAAXXZ			; pulse_generator::sweep
PUBLIC	?envelopes@pulse_generator@@QEAAXXZ		; pulse_generator::envelopes
PUBLIC	?readsample@pulse_generator@@QEAAEXZ		; pulse_generator::readsample
PUBLIC	??0apu@@QEAA@XZ					; apu::apu
PUBLIC	??1apu@@UEAA@XZ					; apu::~apu
PUBLIC	?read@apu@@UEAAEHH@Z				; apu::read
PUBLIC	?write@apu@@UEAAXHHE@Z				; apu::write
PUBLIC	?rundevice@apu@@UEAAHH@Z			; apu::rundevice
PUBLIC	??_Gapu@@UEAAPEAXI@Z				; apu::`scalar deleting destructor'
PUBLIC	__JustMyCode_Default
PUBLIC	??_7apu@@6B@					; apu::`vftable'
PUBLIC	??_C@_0P@IDHECIDN@NES?5APU?5Device@		; `string'
PUBLIC	??_R4apu@@6B@					; apu::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVapu@@@8					; apu `RTTI Type Descriptor'
PUBLIC	??_R3apu@@8					; apu::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2apu@@8					; apu::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@apu@@8				; apu::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bus_device@@8			; bus_device::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVbus_device@@@8				; bus_device `RTTI Type Descriptor'
PUBLIC	??_R3bus_device@@8				; bus_device::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bus_device@@8				; bus_device::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@device@@8				; device::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVdevice@@@8				; device `RTTI Type Descriptor'
PUBLIC	??_R3device@@8					; device::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2device@@8					; device::`RTTI Base Class Array'
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__imp_strcpy_s:PROC
EXTRN	?get_device_descriptor@device@@QEAAPEADXZ:PROC	; device::get_device_descriptor
EXTRN	?dma@device@@UEAAXPEAE_N1@Z:PROC		; device::dma
EXTRN	??0bus_device@@QEAA@XZ:PROC			; bus_device::bus_device
EXTRN	??1bus_device@@UEAA@XZ:PROC			; bus_device::~bus_device
EXTRN	??_Eapu@@UEAAPEAXI@Z:PROC			; apu::`vector deleting destructor'
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
;	COMDAT pdata
pdata	SEGMENT
$pdata$?update_timers@pulse_generator@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+180
	DD	imagerel $unwind$?update_timers@pulse_generator@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?half_clock@pulse_generator@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+129
	DD	imagerel $unwind$?half_clock@pulse_generator@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?quarter_clock@pulse_generator@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?quarter_clock@pulse_generator@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sweep@pulse_generator@@QEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+417
	DD	imagerel $unwind$?sweep@pulse_generator@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?envelopes@pulse_generator@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+300
	DD	imagerel $unwind$?envelopes@pulse_generator@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readsample@pulse_generator@@QEAAEXZ DD imagerel $LN11
	DD	imagerel $LN11+317
	DD	imagerel $unwind$?readsample@pulse_generator@@QEAAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0apu@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+243
	DD	imagerel $unwind$??0apu@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0apu@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0apu@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0apu@@QEAA@XZ@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0apu@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1apu@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$??1apu@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?read@apu@@UEAAEHH@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?read@apu@@UEAAEHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?write@apu@@UEAAXHHE@Z DD imagerel $LN20
	DD	imagerel $LN20+784
	DD	imagerel $unwind$?write@apu@@UEAAXHHE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rundevice@apu@@UEAAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$?rundevice@apu@@UEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gapu@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+105
	DD	imagerel $unwind$??_Gapu@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R2device@@8
rdata$r	SEGMENT
??_R2device@@8 DD imagerel ??_R1A@?0A@EA@device@@8	; device::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3device@@8
rdata$r	SEGMENT
??_R3device@@8 DD 00H					; device::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2device@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVdevice@@@8
data$r	SEGMENT
??_R0?AVdevice@@@8 DQ FLAT:??_7type_info@@6B@		; device `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVdevice@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@device@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@device@@8 DD imagerel ??_R0?AVdevice@@@8	; device::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3device@@8
rdata$r	ENDS
;	COMDAT ??_R2bus_device@@8
rdata$r	SEGMENT
??_R2bus_device@@8 DD imagerel ??_R1A@?0A@EA@bus_device@@8 ; bus_device::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@device@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bus_device@@8
rdata$r	SEGMENT
??_R3bus_device@@8 DD 00H				; bus_device::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bus_device@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbus_device@@@8
data$r	SEGMENT
??_R0?AVbus_device@@@8 DQ FLAT:??_7type_info@@6B@	; bus_device `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbus_device@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bus_device@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bus_device@@8 DD imagerel ??_R0?AVbus_device@@@8 ; bus_device::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bus_device@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@apu@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@apu@@8 DD imagerel ??_R0?AVapu@@@8	; apu::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3apu@@8
rdata$r	ENDS
;	COMDAT ??_R2apu@@8
rdata$r	SEGMENT
??_R2apu@@8 DD	imagerel ??_R1A@?0A@EA@apu@@8		; apu::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bus_device@@8
	DD	imagerel ??_R1A@?0A@EA@device@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3apu@@8
rdata$r	SEGMENT
??_R3apu@@8 DD	00H					; apu::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2apu@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVapu@@@8
data$r	SEGMENT
??_R0?AVapu@@@8 DQ FLAT:??_7type_info@@6B@		; apu `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVapu@@', 00H
data$r	ENDS
;	COMDAT ??_R4apu@@6B@
rdata$r	SEGMENT
??_R4apu@@6B@ DD 01H					; apu::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVapu@@@8
	DD	imagerel ??_R3apu@@8
	DD	imagerel ??_R4apu@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0P@IDHECIDN@NES?5APU?5Device@
CONST	SEGMENT
??_C@_0P@IDHECIDN@NES?5APU?5Device@ DB 'NES APU Device', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7apu@@6B@
CONST	SEGMENT
??_7apu@@6B@ DQ	FLAT:??_R4apu@@6B@			; apu::`vftable'
	DQ	FLAT:?rundevice@apu@@UEAAHH@Z
	DQ	FLAT:?dma@device@@UEAAXPEAE_N1@Z
	DQ	FLAT:??_Eapu@@UEAAPEAXI@Z
	DQ	FLAT:?write@apu@@UEAAXHHE@Z
	DQ	FLAT:?read@apu@@UEAAEHH@Z
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gapu@@UEAAPEAXI@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rundevice@apu@@UEAAHH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?write@apu@@UEAAXHHE@Z DD 025053801H
	DD	011c2321H
	DD	070150025H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?read@apu@@UEAAEHH@Z DD 025053301H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1apu@@UEAA@XZ DD imagerel ??1apu@@UEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1apu@@UEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1apu@@UEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1apu@@UEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1apu@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0apu@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0apu@@QEAA@XZ DD imagerel ??0apu@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0apu@@QEAA@XZ+78
	DD	00H
	DD	imagerel ??0apu@@QEAA@XZ+226
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0apu@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0apu@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0apu@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0apu@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0apu@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0apu@@QEAA@XZ DD 025053511H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0apu@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readsample@pulse_generator@@QEAAEXZ DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?envelopes@pulse_generator@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sweep@pulse_generator@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?quarter_clock@pulse_generator@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?half_clock@pulse_generator@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?update_timers@pulse_generator@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gapu@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gapu@@UEAAPEAXI@Z PROC				; apu::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1apu@@UEAA@XZ				; apu::~apu
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 120				; 00000078H
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gapu@@UEAAPEAXI@Z ENDP				; apu::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ?rundevice@apu@@UEAAHH@Z
_TEXT	SEGMENT
this$ = 224
ticks$ = 232
?rundevice@apu@@UEAAHH@Z PROC				; apu::rundevice, COMDAT

; 57   : int		apu::rundevice(int ticks) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode

; 58   : 	return ticks;

	mov	eax, DWORD PTR ticks$[rbp]

; 59   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?rundevice@apu@@UEAAHH@Z ENDP				; apu::rundevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ?write@apu@@UEAAXHHE@Z
_TEXT	SEGMENT
pulse_sel$1 = 4
cmd$2 = 36
tv173 = 244
tv154 = 244
tv131 = 244
tv89 = 244
tv71 = 244
tv67 = 244
this$ = 288
addr$ = 296
addr_from_base$ = 304
data$ = 312
?write@apu@@UEAAXHHE@Z PROC				; apu::write, COMDAT

; 26   : void	apu::write(int addr, int addr_from_base, byte data) {

$LN20:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode

; 27   : 	if (addr_from_base < 0x08) {

	cmp	DWORD PTR addr_from_base$[rbp], 8
	jge	$LN4@write

; 28   : 		// pulse channels.
; 29   : 		int pulse_sel = (addr_from_base & PULSE2) > 0;

	mov	eax, DWORD PTR addr_from_base$[rbp]
	and	eax, 4
	test	eax, eax
	jle	SHORT $LN10@write
	mov	DWORD PTR tv67[rbp], 1
	jmp	SHORT $LN11@write
$LN10@write:
	mov	DWORD PTR tv67[rbp], 0
$LN11@write:
	mov	eax, DWORD PTR tv67[rbp]
	mov	DWORD PTR pulse_sel$1[rbp], eax

; 30   : 		byte cmd = addr_from_base & 0x03;

	mov	eax, DWORD PTR addr_from_base$[rbp]
	and	eax, 3
	mov	BYTE PTR cmd$2[rbp], al

; 31   : 		switch (cmd) {

	movzx	eax, BYTE PTR cmd$2[rbp]
	mov	BYTE PTR tv71[rbp], al
	cmp	BYTE PTR tv71[rbp], 0
	je	SHORT $LN5@write
	cmp	BYTE PTR tv71[rbp], 1
	je	$LN6@write
	cmp	BYTE PTR tv71[rbp], 2
	je	$LN7@write
	cmp	BYTE PTR tv71[rbp], 3
	je	$LN8@write
	jmp	$LN2@write
$LN5@write:

; 32   : 		case PULSE_DUTY_CYCLE_LCH_VOLENV:
; 33   : 			pulse[pulse_sel].duty_cycle = (data & 0xC0) >> 6;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 192				; 000000c0H
	sar	eax, 6
	movsxd	rcx, DWORD PTR pulse_sel$1[rbp]
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+72], al

; 34   : 			pulse[pulse_sel].envelope_loop = (data & 0x20) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jle	SHORT $LN12@write
	mov	DWORD PTR tv89[rbp], 1
	jmp	SHORT $LN13@write
$LN12@write:
	mov	DWORD PTR tv89[rbp], 0
$LN13@write:
	movsxd	rax, DWORD PTR pulse_sel$1[rbp]
	imul	rax, rax, 22
	mov	rcx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR tv89[rbp]
	mov	BYTE PTR [rcx+rax+74], dl

; 35   : 			pulse[pulse_sel].constant_volume = (data & 0x10) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 16
	test	eax, eax
	jle	SHORT $LN14@write
	mov	DWORD PTR tv131[rbp], 1
	jmp	SHORT $LN15@write
$LN14@write:
	mov	DWORD PTR tv131[rbp], 0
$LN15@write:
	movsxd	rax, DWORD PTR pulse_sel$1[rbp]
	imul	rax, rax, 22
	mov	rcx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR tv131[rbp]
	mov	BYTE PTR [rcx+rax+75], dl

; 36   : 			pulse[pulse_sel].volume_envelope = data & 0x0F;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 15
	movsxd	rcx, DWORD PTR pulse_sel$1[rbp]
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+76], al

; 37   : 			pulse[pulse_sel].envelope_reload = true;

	movsxd	rax, DWORD PTR pulse_sel$1[rbp]
	imul	rax, rax, 22
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+rax+89], 1

; 38   : 			break;

	jmp	$LN2@write
$LN6@write:

; 39   : 		case PULSE_SWEEP:
; 40   : 			pulse[pulse_sel].sweep_enable = (data & 0x80) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jle	SHORT $LN16@write
	mov	DWORD PTR tv154[rbp], 1
	jmp	SHORT $LN17@write
$LN16@write:
	mov	DWORD PTR tv154[rbp], 0
$LN17@write:
	movsxd	rax, DWORD PTR pulse_sel$1[rbp]
	imul	rax, rax, 22
	mov	rcx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR tv154[rbp]
	mov	BYTE PTR [rcx+rax+83], dl

; 41   : 			pulse[pulse_sel].sweep_divider = (data & 0x70) >> 4;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 112				; 00000070H
	sar	eax, 4
	movsxd	rcx, DWORD PTR pulse_sel$1[rbp]
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+84], al

; 42   : 			pulse[pulse_sel].sweep_negate = (data & 0x08) > 0;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 8
	test	eax, eax
	jle	SHORT $LN18@write
	mov	DWORD PTR tv173[rbp], 1
	jmp	SHORT $LN19@write
$LN18@write:
	mov	DWORD PTR tv173[rbp], 0
$LN19@write:
	movsxd	rax, DWORD PTR pulse_sel$1[rbp]
	imul	rax, rax, 22
	mov	rcx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR tv173[rbp]
	mov	BYTE PTR [rcx+rax+86], dl

; 43   : 			pulse[pulse_sel].sweep_shift = (data & 0x07);

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 7
	movsxd	rcx, DWORD PTR pulse_sel$1[rbp]
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+87], al

; 44   : 			pulse[pulse_sel].sweep_reload = true;

	movsxd	rax, DWORD PTR pulse_sel$1[rbp]
	imul	rax, rax, 22
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+rax+88], 1

; 45   : 			break;

	jmp	$LN2@write
$LN7@write:

; 46   : 		case PULSE_TIMER:
; 47   : 			pulse[pulse_sel].timer = (pulse[pulse_sel].timer & 0x0700) | data;

	movsxd	rax, DWORD PTR pulse_sel$1[rbp]
	imul	rax, rax, 22
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+78]
	and	eax, 1792				; 00000700H
	movzx	ecx, BYTE PTR data$[rbp]
	or	eax, ecx
	movsxd	rcx, DWORD PTR pulse_sel$1[rbp]
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+78], ax

; 48   : 			break;

	jmp	SHORT $LN2@write
$LN8@write:

; 49   : 		case PULSE_LCL_TIMER:
; 50   : 			pulse[pulse_sel].timer = (pulse[pulse_sel].timer & 0x00FF) | ((data & 0x07) << 8);

	movsxd	rax, DWORD PTR pulse_sel$1[rbp]
	imul	rax, rax, 22
	mov	rcx, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rcx+rax+78]
	and	eax, 255				; 000000ffH
	movzx	ecx, BYTE PTR data$[rbp]
	and	ecx, 7
	shl	ecx, 8
	or	eax, ecx
	movsxd	rcx, DWORD PTR pulse_sel$1[rbp]
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR this$[rbp]
	mov	WORD PTR [rdx+rcx+78], ax

; 51   : 			pulse[pulse_sel].length_counter = (data & 0xF8) >> 3;

	movzx	eax, BYTE PTR data$[rbp]
	and	eax, 248				; 000000f8H
	sar	eax, 3
	movsxd	rcx, DWORD PTR pulse_sel$1[rbp]
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rdx+rcx+82], al
$LN2@write:
$LN4@write:

; 52   : 			break;
; 53   : 		}
; 54   : 	}
; 55   : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
?write@apu@@UEAAXHHE@Z ENDP				; apu::write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ?read@apu@@UEAAEHH@Z
_TEXT	SEGMENT
this$ = 224
addr$ = 232
addr_from_base$ = 240
?read@apu@@UEAAEHH@Z PROC				; apu::read, COMDAT

; 22   : byte	apu::read(int addr, int addr_from_base) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode

; 23   : 	return BUS_OPEN_BUS;

	mov	al, 240					; 000000f0H

; 24   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?read@apu@@UEAAEHH@Z ENDP				; apu::read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ??1apu@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1apu@@UEAA@XZ PROC					; apu::~apu, COMDAT

; 18   : apu::~apu() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	QWORD PTR $T1[rbp], -2
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7apu@@6B@
	mov	QWORD PTR [rax], rcx

; 19   : 
; 20   : }

	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	npad	1
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??1apu@@UEAA@XZ ENDP					; apu::~apu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ??0apu@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??0apu@@QEAA@XZ PROC					; apu::apu, COMDAT

; 4    : apu::apu() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	QWORD PTR $T1[rbp], -2
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR this$[rbp]
	call	??0bus_device@@QEAA@XZ			; bus_device::bus_device
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7apu@@6B@
	mov	QWORD PTR [rax], rcx

; 5    : 	strcpy_s(this->get_device_descriptor(), MAX_DESCRIPTOR_LENGTH, "NES APU Device");

	mov	rcx, QWORD PTR this$[rbp]
	call	?get_device_descriptor@device@@QEAAPEADXZ ; device::get_device_descriptor
	lea	r8, OFFSET FLAT:??_C@_0P@IDHECIDN@NES?5APU?5Device@
	mov	edx, 128				; 00000080H
	mov	rcx, rax
	call	QWORD PTR __imp_strcpy_s

; 6    : 	devicestart = 0x4000;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+44], 16384		; 00004000H

; 7    : 	deviceend = 0x401F;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+48], 16415		; 0000401fH

; 8    : 	devicemask = 0x401F;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+52], 16415		; 0000401fH

; 9    : 
; 10   : 	// initialize pulse
; 11   : 	pulse[0].pulse2 = false;

	mov	eax, 22
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+rax+92], 0

; 12   : 	pulse[1].pulse2 = true;

	mov	eax, 22
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+rax+92], 1

; 13   : 
; 14   : 	// clocking info.
; 15   : 	tick_rate = 3;	// make it same as cpu. tick_rate is a divider against tick_rate 1

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+16], 3

; 16   : }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??0apu@@QEAA@XZ ENDP					; apu::apu
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0apu@@QEAA@XZ@4HA PROC			; `apu::apu'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0apu@@QEAA@XZ@4HA ENDP			; `apu::apu'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0apu@@QEAA@XZ@4HA PROC			; `apu::apu'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bus_device@@UEAA@XZ			; bus_device::~bus_device
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0apu@@QEAA@XZ@4HA ENDP			; `apu::apu'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ?readsample@pulse_generator@@QEAAEXZ
_TEXT	SEGMENT
output_level$ = 4
duty_out$ = 36
tv147 = 244
tv129 = 244
tv93 = 248
this$ = 288
?readsample@pulse_generator@@QEAAEXZ PROC		; pulse_generator::readsample, COMDAT

; 114  : byte	pulse_generator::readsample() {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode

; 115  : 	// muted conditions.
; 116  : 	if ((timer < 8) || (!sweep_negate && (timer >= 0x078B))) return 0;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+6]
	cmp	eax, 8
	jl	SHORT $LN3@readsample
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+14]
	test	eax, eax
	jne	SHORT $LN2@readsample
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+6]
	cmp	eax, 1931				; 0000078bH
	jl	SHORT $LN2@readsample
$LN3@readsample:
	xor	al, al
	jmp	$LN1@readsample
$LN2@readsample:

; 117  : 	if (length_counter == 0) return 0;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+10]
	test	eax, eax
	jne	SHORT $LN4@readsample
	xor	al, al
	jmp	$LN1@readsample
$LN4@readsample:

; 118  : 
; 119  : 	// constant volume or envelope out?
; 120  : 	byte	output_level = volume_envelope;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+4]
	mov	BYTE PTR output_level$[rbp], al

; 121  : 	if (!constant_volume) output_level = envelope_out;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+3]
	test	eax, eax
	jne	SHORT $LN5@readsample
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+19]
	mov	BYTE PTR output_level$[rbp], al
$LN5@readsample:

; 122  : 	bool duty_out = (1 << (7 - duty_pos)) & duty_cycle_osc[duty_cycle];

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+1]
	mov	ecx, 7
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, 1
	mov	DWORD PTR tv147[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv147[rbp]
	shl	eax, cl
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	lea	rdx, OFFSET FLAT:?duty_cycle_osc@@3QBEB
	movzx	ecx, BYTE PTR [rdx+rcx]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN7@readsample
	mov	BYTE PTR tv93[rbp], 1
	jmp	SHORT $LN8@readsample
$LN7@readsample:
	mov	BYTE PTR tv93[rbp], 0
$LN8@readsample:
	movzx	eax, BYTE PTR tv93[rbp]
	mov	BYTE PTR duty_out$[rbp], al

; 123  : 	return duty_out ? output_level : 0;

	movzx	eax, BYTE PTR duty_out$[rbp]
	test	eax, eax
	je	SHORT $LN9@readsample
	movzx	eax, BYTE PTR output_level$[rbp]
	mov	DWORD PTR tv129[rbp], eax
	jmp	SHORT $LN10@readsample
$LN9@readsample:
	mov	DWORD PTR tv129[rbp], 0
$LN10@readsample:
	movzx	eax, BYTE PTR tv129[rbp]
$LN1@readsample:

; 124  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
?readsample@pulse_generator@@QEAAEXZ ENDP		; pulse_generator::readsample
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ?envelopes@pulse_generator@@QEAAXXZ
_TEXT	SEGMENT
tv93 = 192
tv92 = 196
this$ = 240
?envelopes@pulse_generator@@QEAAXXZ PROC		; pulse_generator::envelopes, COMDAT

; 87   : void	pulse_generator::envelopes() {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode

; 88   : 	if (envelope_reload) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+17]
	test	eax, eax
	je	SHORT $LN2@envelopes

; 89   : 		envelope_count = volume_envelope;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+4]
	mov	BYTE PTR [rax+18], cl

; 90   : 		envelope_out = 0x0F;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+19], 15

; 91   : 		envelope_reload = false;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+17], 0

; 92   : 		return;

	jmp	$LN1@envelopes
$LN2@envelopes:

; 93   : 	}
; 94   : 	if (envelope_count > 0) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+18]
	test	eax, eax
	jle	SHORT $LN3@envelopes

; 95   : 		envelope_count--;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+18]
	dec	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+18], al

; 96   : 	}
; 97   : 	else {

	jmp	$LN4@envelopes
$LN3@envelopes:

; 98   : 		envelope_count = volume_envelope;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+4]
	mov	BYTE PTR [rax+18], cl

; 99   : 		envelope_out = (envelope_out > 0) ? envelope_out - 1 : ((envelope_loop ? 0x0F : envelope_out));

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+19]
	test	eax, eax
	jle	SHORT $LN8@envelopes
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+19]
	dec	eax
	mov	DWORD PTR tv93[rbp], eax
	jmp	SHORT $LN9@envelopes
$LN8@envelopes:
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+2]
	test	eax, eax
	je	SHORT $LN6@envelopes
	mov	DWORD PTR tv92[rbp], 15
	jmp	SHORT $LN7@envelopes
$LN6@envelopes:
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+19]
	mov	DWORD PTR tv92[rbp], eax
$LN7@envelopes:
	mov	eax, DWORD PTR tv92[rbp]
	mov	DWORD PTR tv93[rbp], eax
$LN9@envelopes:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR tv93[rbp]
	mov	BYTE PTR [rax+19], cl
$LN4@envelopes:
$LN1@envelopes:

; 100  : 	}
; 101  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?envelopes@pulse_generator@@QEAAXXZ ENDP		; pulse_generator::envelopes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ?sweep@pulse_generator@@QEAAXXZ
_TEXT	SEGMENT
tv90 = 192
tv140 = 196
tv133 = 200
this$ = 240
?sweep@pulse_generator@@QEAAXXZ PROC			; pulse_generator::sweep, COMDAT

; 71   : void	pulse_generator::sweep() {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode

; 72   : 	if (!sweep_enable) return;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+11]
	test	eax, eax
	jne	SHORT $LN2@sweep
	jmp	$LN1@sweep
$LN2@sweep:

; 73   : 	if ((timer < 8) || (!sweep_negate && (timer >= 0x078B))) return;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+6]
	cmp	eax, 8
	jl	SHORT $LN4@sweep
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+14]
	test	eax, eax
	jne	SHORT $LN3@sweep
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+6]
	cmp	eax, 1931				; 0000078bH
	jl	SHORT $LN3@sweep
$LN4@sweep:
	jmp	$LN1@sweep
$LN3@sweep:

; 74   : 	if (sweep_div_count > 0) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+13]
	test	eax, eax
	jle	SHORT $LN5@sweep

; 75   : 		sweep_div_count--;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+13]
	dec	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+13], al

; 76   : 	}
; 77   : 	else {

	jmp	$LN6@sweep
$LN5@sweep:

; 78   : 		sweep_div_count = sweep_divider;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+12]
	mov	BYTE PTR [rax+13], cl

; 79   : 		timer = sweep_negate ? timer - ((timer >> sweep_shift) + (int)pulse2) : timer + (timer >> sweep_shift);

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+14]
	test	eax, eax
	je	SHORT $LN9@sweep
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+6]
	mov	DWORD PTR tv90[rbp], ecx
	mov	rdx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR [rdx+15]
	movzx	ecx, dl
	mov	edx, DWORD PTR tv90[rbp]
	sar	edx, cl
	mov	ecx, edx
	mov	rdx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR [rdx+20]
	add	ecx, edx
	sub	eax, ecx
	mov	DWORD PTR tv140[rbp], eax
	jmp	SHORT $LN10@sweep
$LN9@sweep:
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+6]
	mov	DWORD PTR tv133[rbp], ecx
	mov	rdx, QWORD PTR this$[rbp]
	movzx	edx, BYTE PTR [rdx+15]
	movzx	ecx, dl
	mov	edx, DWORD PTR tv133[rbp]
	sar	edx, cl
	mov	ecx, edx
	add	eax, ecx
	mov	DWORD PTR tv140[rbp], eax
$LN10@sweep:
	mov	rax, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR tv140[rbp]
	mov	WORD PTR [rax+6], cx
$LN6@sweep:

; 80   : 	}
; 81   : 	if (sweep_reload) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN7@sweep

; 82   : 		sweep_reload = false;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+16], 0

; 83   : 		sweep_div_count = sweep_divider;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, BYTE PTR [rcx+12]
	mov	BYTE PTR [rax+13], cl
$LN7@sweep:
$LN1@sweep:

; 84   : 	}
; 85   : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?sweep@pulse_generator@@QEAAXXZ ENDP			; pulse_generator::sweep
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ?quarter_clock@pulse_generator@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?quarter_clock@pulse_generator@@QEAAXXZ PROC		; pulse_generator::quarter_clock, COMDAT

; 110  : void	pulse_generator::quarter_clock() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode

; 111  : 	envelopes();

	mov	rcx, QWORD PTR this$[rbp]
	call	?envelopes@pulse_generator@@QEAAXXZ	; pulse_generator::envelopes

; 112  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?quarter_clock@pulse_generator@@QEAAXXZ ENDP		; pulse_generator::quarter_clock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ?half_clock@pulse_generator@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?half_clock@pulse_generator@@QEAAXXZ PROC		; pulse_generator::half_clock, COMDAT

; 103  : void	pulse_generator::half_clock() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode

; 104  : 	// sweeper.
; 105  : 	sweep();

	mov	rcx, QWORD PTR this$[rbp]
	call	?sweep@pulse_generator@@QEAAXXZ		; pulse_generator::sweep

; 106  : 	// length counter.
; 107  : 	if (!envelope_loop && (length_counter > 0)) length_counter--;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+2]
	test	eax, eax
	jne	SHORT $LN2@half_clock
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+10]
	test	eax, eax
	jle	SHORT $LN2@half_clock
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+10]
	dec	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+10], al
$LN2@half_clock:

; 108  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?half_clock@pulse_generator@@QEAAXXZ ENDP		; pulse_generator::half_clock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\apu.cpp
;	COMDAT ?update_timers@pulse_generator@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?update_timers@pulse_generator@@QEAAXXZ PROC		; pulse_generator::update_timers, COMDAT

; 62   : void	pulse_generator::update_timers() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__9C647009_apu@cpp
	call	__CheckForDebuggerJustMyCode

; 63   : 	// counter(s)
; 64   : 	if (timer_counter == 0) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+8]
	test	eax, eax
	jne	SHORT $LN2@update_tim

; 65   : 		timer_counter = timer;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	movzx	ecx, WORD PTR [rcx+6]
	mov	WORD PTR [rax+8], cx

; 66   : 		duty_pos--;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+1]
	dec	al
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+1], al

; 67   : 		if (duty_pos == 0xFF) duty_pos = 7;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN4@update_tim
	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+1], 7
$LN4@update_tim:

; 68   : 	} else timer_counter--;

	jmp	SHORT $LN3@update_tim
$LN2@update_tim:
	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, WORD PTR [rax+8]
	dec	ax
	mov	rcx, QWORD PTR this$[rbp]
	mov	WORD PTR [rcx+8], ax
$LN3@update_tim:

; 69   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?update_timers@pulse_generator@@QEAAXXZ ENDP		; pulse_generator::update_timers
_TEXT	ENDS
END

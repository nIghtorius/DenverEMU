; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27050.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@OKGNICPF@Denver?5PPU?5Unit@		; `string'
PUBLIC	??_C@_0P@MFMHDPIH@PPU?5mainram?52k@		; `string'
PUBLIC	??_C@_0BJ@GBIMAOLL@PPU?5palette?5RAM?532?5bytes@ ; `string'
PUBLIC	??_R2ppu@@8					; ppu::`RTTI Base Class Array'
PUBLIC	??_R2ppu_pal_ram@@8				; ppu_pal_ram::`RTTI Base Class Array'
PUBLIC	??_R2ppuram@@8					; ppuram::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ppu@@8				; ppu::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ppu_pal_ram@@8			; ppu_pal_ram::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ppuram@@8				; ppuram::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3ppu@@8					; ppu::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVppu@@@8					; ppu `RTTI Type Descriptor'
PUBLIC	??_R3ppu_pal_ram@@8				; ppu_pal_ram::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVppu_pal_ram@@@8				; ppu_pal_ram `RTTI Type Descriptor'
PUBLIC	??_R3ppuram@@8					; ppuram::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVppuram@@@8				; ppuram `RTTI Type Descriptor'
PUBLIC	??_R4ppu@@6B@					; ppu::`RTTI Complete Object Locator'
PUBLIC	??_R4ppu_pal_ram@@6B@				; ppu_pal_ram::`RTTI Complete Object Locator'
PUBLIC	??_R4ppuram@@6B@				; ppuram::`RTTI Complete Object Locator'
PUBLIC	??_7ppu_pal_ram@@6B@				; ppu_pal_ram::`vftable'
PUBLIC	??_7ppuram@@6B@					; ppuram::`vftable'
PUBLIC	??_7ppu@@6B@					; ppu::`vftable'
;	COMDAT ??_7ppu@@6B@
CONST	SEGMENT
??_7ppu@@6B@ DQ	FLAT:??_R4ppu@@6B@			; ppu::`vftable'
	DQ	FLAT:?rundevice@ppu@@UEAAHH@Z
	DQ	FLAT:?dma@ppu@@UEAAXPEAE_N1@Z
	DQ	FLAT:??_Eppu@@UEAAPEAXI@Z
	DQ	FLAT:?write@ppu@@UEAAXHHE@Z
	DQ	FLAT:?read@ppu@@UEAAEHH@Z
CONST	ENDS
;	COMDAT ??_7ppuram@@6B@
CONST	SEGMENT
??_7ppuram@@6B@ DQ FLAT:??_R4ppuram@@6B@		; ppuram::`vftable'
	DQ	FLAT:?rundevice@device@@UEAAHH@Z
	DQ	FLAT:?dma@device@@UEAAXPEAE_N1@Z
	DQ	FLAT:??_Eppuram@@UEAAPEAXI@Z
	DQ	FLAT:?write@ppuram@@UEAAXHHE@Z
	DQ	FLAT:?read@ppuram@@UEAAEHH@Z
CONST	ENDS
;	COMDAT ??_7ppu_pal_ram@@6B@
CONST	SEGMENT
??_7ppu_pal_ram@@6B@ DQ FLAT:??_R4ppu_pal_ram@@6B@	; ppu_pal_ram::`vftable'
	DQ	FLAT:?rundevice@device@@UEAAHH@Z
	DQ	FLAT:?dma@device@@UEAAXPEAE_N1@Z
	DQ	FLAT:??_Eppu_pal_ram@@UEAAPEAXI@Z
	DQ	FLAT:?write@ppu_pal_ram@@UEAAXHHE@Z
	DQ	FLAT:?read@ppu_pal_ram@@UEAAEHH@Z
CONST	ENDS
;	COMDAT ??_R4ppuram@@6B@
rdata$r	SEGMENT
??_R4ppuram@@6B@ DD 01H					; ppuram::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVppuram@@@8
	DD	imagerel ??_R3ppuram@@8
	DD	imagerel ??_R4ppuram@@6B@
rdata$r	ENDS
;	COMDAT ??_R4ppu_pal_ram@@6B@
rdata$r	SEGMENT
??_R4ppu_pal_ram@@6B@ DD 01H				; ppu_pal_ram::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVppu_pal_ram@@@8
	DD	imagerel ??_R3ppu_pal_ram@@8
	DD	imagerel ??_R4ppu_pal_ram@@6B@
rdata$r	ENDS
;	COMDAT ??_R4ppu@@6B@
rdata$r	SEGMENT
??_R4ppu@@6B@ DD 01H					; ppu::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVppu@@@8
	DD	imagerel ??_R3ppu@@8
	DD	imagerel ??_R4ppu@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVppuram@@@8
data$r	SEGMENT
??_R0?AVppuram@@@8 DQ FLAT:??_7type_info@@6B@		; ppuram `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVppuram@@', 00H
data$r	ENDS
;	COMDAT ??_R3ppuram@@8
rdata$r	SEGMENT
??_R3ppuram@@8 DD 00H					; ppuram::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2ppuram@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVppu_pal_ram@@@8
data$r	SEGMENT
??_R0?AVppu_pal_ram@@@8 DQ FLAT:??_7type_info@@6B@	; ppu_pal_ram `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVppu_pal_ram@@', 00H
data$r	ENDS
;	COMDAT ??_R3ppu_pal_ram@@8
rdata$r	SEGMENT
??_R3ppu_pal_ram@@8 DD 00H				; ppu_pal_ram::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2ppu_pal_ram@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVppu@@@8
data$r	SEGMENT
??_R0?AVppu@@@8 DQ FLAT:??_7type_info@@6B@		; ppu `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVppu@@', 00H
data$r	ENDS
;	COMDAT ??_R3ppu@@8
rdata$r	SEGMENT
??_R3ppu@@8 DD	00H					; ppu::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2ppu@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ppuram@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ppuram@@8 DD imagerel ??_R0?AVppuram@@@8	; ppuram::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ppuram@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ppu_pal_ram@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ppu_pal_ram@@8 DD imagerel ??_R0?AVppu_pal_ram@@@8 ; ppu_pal_ram::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ppu_pal_ram@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ppu@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ppu@@8 DD imagerel ??_R0?AVppu@@@8	; ppu::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ppu@@8
rdata$r	ENDS
;	COMDAT ??_R2ppuram@@8
rdata$r	SEGMENT
??_R2ppuram@@8 DD imagerel ??_R1A@?0A@EA@ppuram@@8	; ppuram::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bus_device@@8
	DD	imagerel ??_R1A@?0A@EA@device@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2ppu_pal_ram@@8
rdata$r	SEGMENT
??_R2ppu_pal_ram@@8 DD imagerel ??_R1A@?0A@EA@ppu_pal_ram@@8 ; ppu_pal_ram::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bus_device@@8
	DD	imagerel ??_R1A@?0A@EA@device@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2ppu@@8
rdata$r	SEGMENT
??_R2ppu@@8 DD	imagerel ??_R1A@?0A@EA@ppu@@8		; ppu::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bus_device@@8
	DD	imagerel ??_R1A@?0A@EA@device@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_C@_0BJ@GBIMAOLL@PPU?5palette?5RAM?532?5bytes@
CONST	SEGMENT
??_C@_0BJ@GBIMAOLL@PPU?5palette?5RAM?532?5bytes@ DB 'PPU palette RAM 32 b'
	DB	'ytes', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MFMHDPIH@PPU?5mainram?52k@
CONST	SEGMENT
??_C@_0P@MFMHDPIH@PPU?5mainram?52k@ DB 'PPU mainram 2k', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OKGNICPF@Denver?5PPU?5Unit@
CONST	SEGMENT
??_C@_0BA@OKGNICPF@Denver?5PPU?5Unit@ DB 'Denver PPU Unit', 00H ; `string'
PUBLIC	?read@ppu_pal_ram@@UEAAEHH@Z			; ppu_pal_ram::read
PUBLIC	?write@ppu_pal_ram@@UEAAXHHE@Z			; ppu_pal_ram::write
PUBLIC	?pal_addr_compute@ppu_pal_ram@@AEAAHH@Z		; ppu_pal_ram::pal_addr_compute
PUBLIC	??1ppu_pal_ram@@UEAA@XZ				; ppu_pal_ram::~ppu_pal_ram
PUBLIC	??_Gppu_pal_ram@@UEAAPEAXI@Z			; ppu_pal_ram::`scalar deleting destructor'
PUBLIC	??0ppu_pal_ram@@QEAA@XZ				; ppu_pal_ram::ppu_pal_ram
PUBLIC	?read@ppuram@@UEAAEHH@Z				; ppuram::read
PUBLIC	?write@ppuram@@UEAAXHHE@Z			; ppuram::write
PUBLIC	??1ppuram@@UEAA@XZ				; ppuram::~ppuram
PUBLIC	??_Gppuram@@UEAAPEAXI@Z				; ppuram::`scalar deleting destructor'
PUBLIC	??0ppuram@@QEAA@XZ				; ppuram::ppuram
PUBLIC	?dma@ppu@@UEAAXPEAE_N1@Z			; ppu::dma
PUBLIC	?rundevice@ppu@@UEAAHH@Z			; ppu::rundevice
PUBLIC	?write@ppu@@UEAAXHHE@Z				; ppu::write
PUBLIC	?read@ppu@@UEAAEHH@Z				; ppu::read
PUBLIC	??1ppu@@UEAA@XZ					; ppu::~ppu
PUBLIC	??_Gppu@@UEAAPEAXI@Z				; ppu::`scalar deleting destructor'
PUBLIC	??0ppu@@QEAA@XZ					; ppu::ppu
PUBLIC	?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z	; ppu::set_char_rom
PUBLIC	?configure_horizontal_mirror@ppu@@QEAAXXZ	; ppu::configure_horizontal_mirror
PUBLIC	?isFrameReady@ppu@@QEAA_NXZ			; ppu::isFrameReady
PUBLIC	?getFrameBuffer@ppu@@QEAAPEAXXZ			; ppu::getFrameBuffer
EXTRN	??_Eppuram@@UEAAPEAXI@Z:PROC			; ppuram::`vector deleting destructor'
EXTRN	??_Eppu_pal_ram@@UEAAPEAXI@Z:PROC		; ppu_pal_ram::`vector deleting destructor'
EXTRN	??_Eppu@@UEAAPEAXI@Z:PROC			; ppu::`vector deleting destructor'
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ppu_pal_ram@@UEAA@XZ DD imagerel $LN10@ppu_pal_ra
	DD	imagerel $LN10@ppu_pal_ra+55
	DD	imagerel $unwind$??1ppu_pal_ram@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gppu_pal_ram@@UEAAPEAXI@Z DD imagerel $LN15@scalar
	DD	imagerel $LN15@scalar+87
	DD	imagerel $unwind$??_Gppu_pal_ram@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ppu_pal_ram@@QEAA@XZ DD imagerel $LN7@ppu_pal_ra
	DD	imagerel $LN7@ppu_pal_ra+91
	DD	imagerel $unwind$??0ppu_pal_ram@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ppuram@@UEAA@XZ DD imagerel $LN10@ppuram
	DD	imagerel $LN10@ppuram+55
	DD	imagerel $unwind$??1ppuram@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gppuram@@UEAAPEAXI@Z DD imagerel $LN15@scalar
	DD	imagerel $LN15@scalar+87
	DD	imagerel $unwind$??_Gppuram@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ppuram@@QEAA@XZ DD imagerel $LN7@ppuram
	DD	imagerel $LN7@ppuram+91
	DD	imagerel $unwind$??0ppuram@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rundevice@ppu@@UEAAHH@Z DD imagerel $LN148
	DD	imagerel $LN148+40
	DD	imagerel $unwind$?rundevice@ppu@@UEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?rundevice@ppu@@UEAAHH@Z DD imagerel $LN148+40
	DD	imagerel $LN148+2843
	DD	imagerel $chain$3$?rundevice@ppu@@UEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?rundevice@ppu@@UEAAHH@Z DD imagerel $LN148+2843
	DD	imagerel $LN148+2855
	DD	imagerel $chain$4$?rundevice@ppu@@UEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?write@ppu@@UEAAXHHE@Z DD imagerel $LN19@write
	DD	imagerel $LN19@write+619
	DD	imagerel $unwind$?write@ppu@@UEAAXHHE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?read@ppu@@UEAAEHH@Z DD imagerel $LN15@read
	DD	imagerel $LN15@read+152
	DD	imagerel $unwind$?read@ppu@@UEAAEHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?read@ppu@@UEAAEHH@Z DD imagerel $LN15@read+152
	DD	imagerel $LN15@read+220
	DD	imagerel $chain$0$?read@ppu@@UEAAEHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?read@ppu@@UEAAEHH@Z DD imagerel $LN15@read+220
	DD	imagerel $LN15@read+228
	DD	imagerel $chain$1$?read@ppu@@UEAAEHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ppu@@UEAA@XZ DD imagerel $LN248@ppu
	DD	imagerel $LN248@ppu+341
	DD	imagerel $unwind$??1ppu@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gppu@@UEAAPEAXI@Z DD imagerel $LN253@scalar
	DD	imagerel $LN253@scalar+380
	DD	imagerel $unwind$??_Gppu@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ppu@@QEAA@XZ DD imagerel $LN189@ppu
	DD	imagerel $LN189@ppu+439
	DD	imagerel $unwind$??0ppu@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z DD imagerel $LN195@set_char_r
	DD	imagerel $LN195@set_char_r+177
	DD	imagerel $unwind$?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?set_char_rom@ppu@@QEAAXPEAVbus_device@@@Z DD 041919H
	DD	09340aH
	DD	07006520aH
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ppu@@QEAA@XZ DD imagerel ??0ppu@@QEAA@XZ+339
	DD	03H
	DD	imagerel ??0ppu@@QEAA@XZ+417
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ppu@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0ppu@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0ppu@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0ppu@@QEAA@XZ@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0???0ppu@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ppu@@QEAA@XZ DQ 00000000419930522r	; 8.69997e-314
	DD	imagerel $stateUnwindMap$??0ppu@@QEAA@XZ
	DQ	00000000000000000r		; 0
	DD	02H
	DD	imagerel $ip2state$??0ppu@@QEAA@XZ
	DQ	00000000000000020r		; 1.58101e-322
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ppu@@QEAA@XZ DD 081c11H
	DD	0e541cH
	DD	0d3417H
	DD	0e0057209H
	DD	060027003H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ppu@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gppu@@UEAAPEAXI@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ppu@@UEAA@XZ DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?read@ppu@@UEAAEHH@Z DD 021H
	DD	imagerel $LN15@read
	DD	imagerel $LN15@read+152
	DD	imagerel $unwind$?read@ppu@@UEAAEHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?read@ppu@@UEAAEHH@Z DD 020521H
	DD	063405H
	DD	imagerel $LN15@read
	DD	imagerel $LN15@read+152
	DD	imagerel $unwind$?read@ppu@@UEAAEHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?read@ppu@@UEAAEHH@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?write@ppu@@UEAAXHHE@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?rundevice@ppu@@UEAAHH@Z DD 021H
	DD	imagerel $LN148
	DD	imagerel $LN148+40
	DD	imagerel $unwind$?rundevice@ppu@@UEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?rundevice@ppu@@UEAAHH@Z DD 082021H
	DD	04f420H
	DD	0cd416H
	DD	0bc40eH
	DD	0a7405H
	DD	imagerel $LN148
	DD	imagerel $LN148+40
	DD	imagerel $unwind$?rundevice@ppu@@UEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rundevice@ppu@@UEAAHH@Z DD 050a01H
	DD	0e006420aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ppuram@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gppuram@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ppuram@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ppu_pal_ram@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gppu_pal_ram@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ppu_pal_ram@@UEAA@XZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp
;	COMDAT ?rundevice@ppu@@UEAAHH@Z
_TEXT	SEGMENT
this$ = 80
ticks$ = 88
?rundevice@ppu@@UEAAHH@Z PROC				; ppu::rundevice, COMDAT

; 134  : int		ppu::rundevice(int ticks) {

$LN148:
	push	rbx
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 40					; 00000028H

; 135  : 	// run the PPU..
; 136  : 	for (int i = 0; i < ticks; i++) {

	xor	r14d, r14d
	mov	ebp, edx
	mov	rbx, rcx
	mov	esi, r14d
	test	edx, edx
	jle	$LN142@rundevice

; 316  : 				ppu_internal.v_register = (ppu_internal.v_register & ~0x041F) | (ppu_internal.t_register & 0x041F);

	mov	r8d, DWORD PTR [rcx+220]
	lea	r10d, QWORD PTR [r14+8]
	mov	QWORD PTR [rsp+80], rdi
	lea	r11d, QWORD PTR [r14+16]
	mov	QWORD PTR [rsp+88], r12
	mov	r9d, r8d
	mov	QWORD PTR [rsp+96], r13
	mov	edi, 64480				; 0000fbe0H
	mov	QWORD PTR [rsp+32], r15
	mov	r13d, 28672				; 00007000H
	lea	r15, QWORD PTR [r14-1]
	mov	r12d, 340				; 00000154H
$LL4@rundevice:

; 137  : 		if ((ppumask.showbg || ppumask.showspr) && !((scanline>=240) && (scanline<=260))) {

	cmp	BYTE PTR [rbx+82], r14b
	jne	SHORT $LN11@rundevice
	cmp	BYTE PTR [rbx+83], r14b
	je	$LN60@rundevice
$LN11@rundevice:
	mov	eax, DWORD PTR [rbx+212]
	cmp	eax, 240				; 000000f0H
	jl	SHORT $LN12@rundevice
	cmp	eax, 260				; 00000104H
	jle	$LN60@rundevice
$LN12@rundevice:

; 138  : 			// loading cycles.
; 139  : 			if (((cycle >= 1) && (cycle <= 256)) | ((cycle >= 321) && (cycle <= 340))) {

	lea	eax, DWORD PTR [r9-321]
	mov	ecx, r14d
	cmp	eax, 19
	lea	edx, DWORD PTR [r9-1]
	mov	eax, r14d
	setbe	cl
	cmp	edx, 255				; 000000ffH
	setbe	al
	or	ecx, eax
	je	$LN23@rundevice

; 140  : 				if (((cycle - 1) % 8) == 1) {

	and	edx, -2147483641			; ffffffff80000007H
	jge	SHORT $LN141@rundevice
	dec	edx
	or	edx, -8
	inc	edx
$LN141@rundevice:
	cmp	edx, 1
	jne	SHORT $LN14@rundevice

; 142  : 					ppu_internal.shiftreg_nametable = vbus.readmemory(0x2000 | (ppu_internal.v_register & 0x0FFF));

	movzx	eax, WORD PTR [rbx+102]
	lea	rcx, QWORD PTR [rbx+240]
	and	eax, 4095				; 00000fffH
	bts	eax, 13
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp

; 23   : 	address = addr;

	mov	DWORD PTR [rcx], eax

; 24   : 	return read();

	call	?read@bus@@QEAAEXZ			; bus::read
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp

; 142  : 					ppu_internal.shiftreg_nametable = vbus.readmemory(0x2000 | (ppu_internal.v_register & 0x0FFF));

	mov	BYTE PTR [rbx+201], al
	jmp	$LN143@rundevice
$LN14@rundevice:

; 143  : 				}
; 144  : 				else if (((cycle - 1) % 8) == 3) {					

	cmp	edx, 3
	jne	SHORT $LN16@rundevice

; 145  : 					// load attribute table shift register.
; 146  : 					word attr_address = ppu_internal.v_register & ~0x2000;
; 147  : 					attr_address = 0x03C0 | (attr_address & 0x0C00) | ((attr_address >> 4) & 0x0038) | ((attr_address >> 2) & 0x0007);

	movzx	edx, WORD PTR [rbx+102]

; 148  : 					// better fetch the palette entry @ latch mode, finding it later is incredibly difficult.
; 149  : 					byte ab = vbus.readmemory(attr_address | 0x2000);

	lea	rcx, QWORD PTR [rbx+240]
	mov	r8d, edx
	mov	eax, edx
	and	r8d, 896				; 00000380H
	and	eax, 28
	or	r8d, 146432				; 00023c00H
	and	edx, 3072				; 00000c00H
	shr	r8d, 2
	or	r8d, eax
	shr	r8d, 2
	or	r8d, edx
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp

; 23   : 	address = addr;

	mov	DWORD PTR [rcx], r8d

; 24   : 	return read();

	call	?read@bus@@QEAAEXZ			; bus::read
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp

; 150  : 					ppu_internal.shiftreg_attribute_latch = ab;

	mov	BYTE PTR [rbx+114], al
	jmp	$LN143@rundevice
$LN16@rundevice:

; 151  : 				}
; 152  : 				else if (((cycle - 1) % 8) == 5) {

	cmp	edx, 5
	jne	SHORT $LN18@rundevice

; 153  : 					// load pattern table tile low
; 154  : 					ppu_internal.y_shift = (ppu_internal.v_register & 0x7000) >> 12;

	movzx	eax, WORD PTR [rbx+102]

; 157  : 					ppu_internal.shiftregs_pattern_latch = (vbus.readmemory(pattern_address)); // read to lower part.

	lea	rcx, QWORD PTR [rbx+240]
	movzx	edx, BYTE PTR [rbx+75]
	shl	edx, 8
	shr	ax, 12
	and	al, 7
	movzx	r8d, al
	movzx	eax, BYTE PTR [rbx+201]
	or	edx, eax
	mov	BYTE PTR [rbx+98], r8b
	and	edx, 4095				; 00000fffH
	shl	edx, 4
	or	edx, r8d
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp

; 23   : 	address = addr;

	mov	DWORD PTR [rcx], edx

; 24   : 	return read();

	call	?read@bus@@QEAAEXZ			; bus::read
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp

; 157  : 					ppu_internal.shiftregs_pattern_latch = (vbus.readmemory(pattern_address)); // read to lower part.

	mov	BYTE PTR [rbx+104], al
	jmp	$LN143@rundevice
$LN18@rundevice:

; 158  : 				}
; 159  : 				else if (((cycle - 1) % 8) == 7) {

	cmp	edx, 7
	jne	$LN23@rundevice

; 160  : 					// load pattern table tile high
; 161  : 					word pattern_address = (ppuctrl.bg_0x1000 << 12) | ((word)ppu_internal.shiftreg_nametable << 4) | 8 | ppu_internal.y_shift;

	movzx	r10d, BYTE PTR [rbx+98]
	movzx	edx, BYTE PTR [rbx+75]
	or	r10b, 8
	movzx	r8d, BYTE PTR [rbx+201]

; 162  : 					//ppu_internal.shiftregs_pattern_par[1] = vbus->readmemory(pattern_address);
; 163  : 					if (cycle >= 321) {

	cmp	r9d, 321				; 00000141H
	jl	SHORT $LN133@rundevice

; 164  : 						ppu_internal.shiftregs_pattern[0] <<= 8; // clean upper part.

	shl	WORD PTR [rbx+106], 8

; 165  : 						ppu_internal.shiftregs_pattern[1] <<= 8; // clean upper part.

	shl	WORD PTR [rbx+108], 8

; 166  : 						ppu_internal.shiftreg_attribute[0] <<= 8; // clean upper part.

	shl	WORD PTR [rbx+110], 8

; 167  : 						ppu_internal.shiftreg_attribute[1] <<= 8; // clean upper part.

	shl	WORD PTR [rbx+112], 8
$LN133@rundevice:

; 169  : 					ppu_internal.shiftregs_pattern[1] |= (vbus.readmemory(pattern_address)); // read to lower part.

	movzx	edx, dl
	lea	rcx, QWORD PTR [rbx+240]
	shl	edx, 8
	movzx	eax, r8b
	or	edx, eax
	movzx	eax, r10b
	shl	edx, 4
	or	edx, eax
	movzx	eax, dx
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp

; 23   : 	address = addr;

	mov	DWORD PTR [rcx], eax

; 24   : 	return read();

	call	?read@bus@@QEAAEXZ			; bus::read
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp

; 169  : 					ppu_internal.shiftregs_pattern[1] |= (vbus.readmemory(pattern_address)); // read to lower part.

	movzx	eax, al
	or	WORD PTR [rbx+108], ax

; 170  : 					ppu_internal.shiftregs_pattern[0] |= ppu_internal.shiftregs_pattern_latch;

	movzx	eax, BYTE PTR [rbx+104]
	or	WORD PTR [rbx+106], ax

; 171  : 
; 172  : 					byte color = ((ppu_internal.shiftreg_attribute_latch) >> (((((ppu_internal.v_register & 0x1F) >> 1) % 2) << 1) | ((((ppu_internal.v_register & 0x3E0) >> 6) % 2) << 2)) & 0x03);

	movzx	ecx, WORD PTR [rbx+102]
	mov	eax, ecx
	shr	eax, 6
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN140@rundevice
	dec	eax
	or	eax, -2
	inc	eax
$LN140@rundevice:
	add	al, al
	shr	ecx, 1
	and	ecx, -2147483647			; ffffffff80000001H
	jge	SHORT $LN139@rundevice
	dec	ecx
	or	ecx, -2
	inc	ecx
$LN139@rundevice:
	or	al, cl
	movzx	edx, BYTE PTR [rbx+114]
	lea	ecx, DWORD PTR [rax+rax]
	shr	dl, cl

; 173  : 					byte cb1 = color & 0x01;

	movzx	eax, dl

; 174  : 					byte cb2 = (color >> 1) & 0x01;					

	shr	dl, 1
	and	al, 1
	and	dl, 1

; 175  : 					ppu_internal.shiftreg_attribute[0] |= cb1 | (cb1 << 1) | (cb1 << 2) | (cb1 << 3) | (cb1 << 4) | (cb1 << 5) | (cb1 << 6) | (cb1 << 7);

	movzx	ecx, al
	movzx	eax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx

; 176  : 					ppu_internal.shiftreg_attribute[1] |= cb2 | (cb2 << 1) | (cb2 << 2) | (cb2 << 3) | (cb2 << 4) | (cb2 << 5) | (cb2 << 6) | (cb2 << 7);

	movzx	ecx, dl
	or	WORD PTR [rbx+110], ax
	movzx	eax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	add	ax, ax
	or	ax, cx
	or	WORD PTR [rbx+112], ax

; 177  : 
; 178  : 					// last fetch also update Coarse X (v register) (loopy_v verti)
; 179  : 					if ((ppu_internal.v_register & 0x001F) == 31) {

	movzx	ecx, WORD PTR [rbx+102]
	movzx	eax, cl
	and	al, 31
	cmp	al, 31
	jne	SHORT $LN22@rundevice

; 180  : 						ppu_internal.v_register &= ~0x001F;
; 181  : 						ppu_internal.v_register ^= 0x0400;

	mov	eax, 1024				; 00000400H
	xor	cx, ax
	mov	eax, 65504				; 0000ffe0H
	and	cx, ax

; 182  : 					}
; 183  : 					else {

	jmp	SHORT $LN144@rundevice
$LN22@rundevice:

; 184  : 						ppu_internal.v_register++;

	inc	cx
$LN144@rundevice:

; 185  : 					}
; 186  : 				}
; 187  : 			}
; 188  : 			// secondary OAM reset (cycli 1--64)
; 189  : 			if ((cycle >= 1) && (cycle <= 64)) {

	mov	WORD PTR [rbx+102], cx
$LN143@rundevice:
	mov	r10d, 8
	lea	r11d, QWORD PTR [r10+8]
$LN23@rundevice:
	mov	eax, DWORD PTR [rbx+220]
	mov	ecx, eax
	cmp	eax, 1
	jl	SHORT $LN24@rundevice
	cmp	eax, 64					; 00000040H
	jg	SHORT $LN24@rundevice

; 190  : 				ppu_internal.oam_clearing = true;
; 191  : 				byte secaddr = (cycle - 1) % 8;
; 192  : 				memset(&ppu_internal.secoam[(cycle - 1) % 8], 0xFF, 4);

	dec	eax
	mov	BYTE PTR [rbx+166], 1
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN138@rundevice
	dec	eax
	or	eax, -8
	inc	eax
$LN138@rundevice:
	cdqe
	mov	DWORD PTR [rbx+rax*4+115], r15d

; 193  : 				ppu_internal.n = 0;
; 194  : 				ppu_internal.m = 0;
; 195  : 				ppu_internal.sn = 0;
; 196  : 				ppu_internal.oam_evald = false;

	mov	ecx, DWORD PTR [rbx+220]
	mov	WORD PTR [rbx+160], r14w
	mov	BYTE PTR [rbx+162], r14b
	mov	BYTE PTR [rbx+168], r14b
$LN24@rundevice:

; 197  : 			}
; 198  : 			// sprite eval (cycli 65--256)
; 199  : 			if ((cycle >= 65) && (cycle <= 256)) {				

	lea	eax, DWORD PTR [rcx-65]
	cmp	eax, 191				; 000000bfH
	ja	$LN39@rundevice

; 200  : 				ppu_internal.oam_clearing = false;
; 201  : 				bool odd = (cycle % 2) > 0;

	movzx	edx, BYTE PTR [rbx+161]
	mov	BYTE PTR [rbx+166], r14b
	and	ecx, -2147483647			; ffffffff80000001H
	jge	SHORT $LN137@rundevice
	dec	ecx
	or	ecx, -2
	inc	ecx
$LN137@rundevice:
	test	ecx, ecx

; 202  : 				if (odd) {

	jle	SHORT $LN26@rundevice

; 203  : 					// odd cycle (read from primary OAM)
; 204  : 					ppu_internal.secoamb = (byte *)&oam[ppu_internal.n];

	movzx	eax, BYTE PTR [rbx+160]
	add	rax, 110				; 0000006eH
	lea	rcx, QWORD PTR [rbx+rax*4]

; 205  : 					ppu_internal.buffer_oam_read = ppu_internal.secoamb[ppu_internal.m];

	movzx	eax, dl
	mov	QWORD PTR [rbx+152], rcx
	movzx	ecx, BYTE PTR [rax+rcx]
	mov	BYTE PTR [rbx+165], cl

; 206  : 				} else {

	jmp	$LN39@rundevice
$LN26@rundevice:

; 207  : 					// even cycle (write to secondary OAM)
; 208  : 					if (ppu_internal.m == 0) {

	test	dl, dl
	jne	SHORT $LN30@rundevice

; 209  : 						int scancomp = (scanline == 261) ? -1 : scanline;

	mov	edx, DWORD PTR [rbx+212]
	cmp	edx, 261				; 00000105H

; 210  : 						if ((ppu_internal.sn < 8) && !ppu_internal.oam_evald) ppu_internal.secoam[ppu_internal.sn].y = ppu_internal.buffer_oam_read;

	movzx	eax, BYTE PTR [rbx+162]
	cmove	edx, r15d
	cmp	al, 8
	jae	SHORT $LN29@rundevice
	cmp	BYTE PTR [rbx+168], r14b
	jne	SHORT $LN29@rundevice
	movzx	ecx, al
	movzx	eax, BYTE PTR [rbx+165]
	mov	BYTE PTR [rbx+rcx*4+115], al
$LN29@rundevice:

; 211  : 						ppu_internal.oam_copy =

	movzx	ecx, BYTE PTR [rbx+165]
	cmp	edx, ecx
	jl	SHORT $LN97@rundevice
	cmp	BYTE PTR [rbx+76], r14b
	mov	eax, r10d
	cmovne	eax, r11d
	add	eax, ecx
	cmp	edx, eax
	jge	SHORT $LN97@rundevice
	mov	al, 1
	jmp	SHORT $LN98@rundevice
$LN97@rundevice:
	xor	al, al
$LN98@rundevice:
	mov	BYTE PTR [rbx+167], al

; 212  : 							(scancomp >= ppu_internal.buffer_oam_read) &&
; 213  : 							(scancomp < (int)ppu_internal.buffer_oam_read + (ppuctrl.sprites_8x16 ? 16 : 8));
; 214  : 							
; 215  : 						if (ppu_internal.oam_copy && (ppu_internal.sn >= 8)) {

	test	al, al
	je	SHORT $LN30@rundevice
	cmp	BYTE PTR [rbx+162], 8
	jb	SHORT $LN30@rundevice

; 216  : 							// sprite overflow.
; 217  : 							ppustatus.sprite_overflow = true;

	mov	BYTE PTR [rbx+87], 1
$LN30@rundevice:

; 218  : 						}
; 219  : 					}
; 220  : 					// copy cycles.
; 221  : 					if (ppu_internal.oam_copy) {

	cmp	BYTE PTR [rbx+167], r14b
	je	$LN31@rundevice

; 222  : 						if ((ppu_internal.sn < 8) && !ppu_internal.oam_evald) {

	movzx	edx, BYTE PTR [rbx+162]
	cmp	dl, 8
	jae	SHORT $LN5@rundevice
	cmp	BYTE PTR [rbx+168], r14b
	jne	SHORT $LN5@rundevice

; 223  : 							switch (ppu_internal.m) {

	movzx	ecx, BYTE PTR [rbx+161]
	sub	ecx, 1
	je	SHORT $LN34@rundevice
	sub	ecx, 1
	je	SHORT $LN35@rundevice
	sub	ecx, 1
	jne	SHORT $LN5@rundevice

; 228  : 							case 0x03:	ppu_internal.secoam[ppu_internal.sn].x = ppu_internal.buffer_oam_read;

	movzx	eax, BYTE PTR [rbx+165]
	movzx	ecx, dl
	mov	BYTE PTR [rbx+rcx*4+118], al
	jmp	SHORT $LN5@rundevice
$LN35@rundevice:

; 225  : 								break;
; 226  : 							case 0x02:	ppu_internal.secoam[ppu_internal.sn].attr = ppu_internal.buffer_oam_read;

	movzx	eax, BYTE PTR [rbx+165]
	movzx	ecx, dl
	mov	BYTE PTR [rbx+rcx*4+117], al

; 227  : 								break;

	jmp	SHORT $LN5@rundevice
$LN34@rundevice:

; 224  : 							case 0x01:	ppu_internal.secoam[ppu_internal.sn].tile = ppu_internal.buffer_oam_read;

	movzx	eax, BYTE PTR [rbx+165]
	movzx	ecx, dl
	mov	BYTE PTR [rbx+rcx*4+116], al
$LN5@rundevice:

; 229  : 								break;
; 230  : 							}
; 231  : 						}
; 232  : 						ppu_internal.m++;

	inc	BYTE PTR [rbx+161]

; 233  : 						if (ppu_internal.m == 4) {

	cmp	BYTE PTR [rbx+161], 4
	movzx	eax, BYTE PTR [rbx+160]
	jne	SHORT $LN32@rundevice

; 234  : 							// m overflows, reset to 0 and increment n.
; 235  : 							ppu_internal.m = 0;
; 236  : 							ppu_internal.n++;
; 237  : 							if (ppu_internal.sn < 8) ppu_internal.sn++;

	movzx	ecx, BYTE PTR [rbx+162]
	inc	al
	mov	BYTE PTR [rbx+161], r14b
	mov	BYTE PTR [rbx+160], al
	cmp	cl, 8
	jae	SHORT $LN38@rundevice
	inc	cl
	mov	BYTE PTR [rbx+162], cl
$LN38@rundevice:

; 238  : 							ppu_internal.oam_copy = false;	// disable copy system.

	mov	BYTE PTR [rbx+167], r14b
	jmp	SHORT $LN32@rundevice
$LN31@rundevice:

; 239  : 						}
; 240  : 					}
; 241  : 					else {
; 242  : 						// wrap n
; 243  : 						// increment n when no copy is required.
; 244  : 						ppu_internal.n++;

	inc	BYTE PTR [rbx+160]
	movzx	eax, BYTE PTR [rbx+160]
$LN32@rundevice:

; 245  : 					}
; 246  : 					// spr overflow bug?
; 247  : 					//if (ppustatus.sprite_overflow && (ppu_internal.sn < 8)) ppu_internal.n++;
; 248  : 					// wrap n
; 249  : 					if (ppu_internal.n == 64) {

	cmp	al, 64					; 00000040H
	jne	SHORT $LN39@rundevice

; 250  : 						ppu_internal.oam_evald = true;

	mov	BYTE PTR [rbx+168], 1

; 251  : 						ppu_internal.n = 0;

	mov	BYTE PTR [rbx+160], r14b
$LN39@rundevice:

; 252  : 					}
; 253  : 				}
; 254  : 			}
; 255  : 			// sprite loading.
; 256  : 			if ((cycle >= 257) && (cycle <= 320) && (scanline != 261)) {

	mov	ecx, DWORD PTR [rbx+220]
	lea	eax, DWORD PTR [rcx-257]
	cmp	eax, 63					; 0000003fH
	ja	$LN52@rundevice
	mov	edx, DWORD PTR [rbx+212]
	cmp	edx, 261				; 00000105H
	je	$LN52@rundevice

; 257  : 				if (cycle == 257) ppu_internal.n = 0;

	cmp	ecx, 257				; 00000101H
	jne	SHORT $LN134@rundevice
	mov	BYTE PTR [rbx+160], r14b
$LN134@rundevice:

; 258  : 				byte cs = (cycle - 1) % 8;

	lea	eax, DWORD PTR [rcx-1]
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN136@rundevice
	dec	eax
	or	eax, -8
	inc	eax
$LN136@rundevice:

; 259  : 				if (cs == 1) {

	cmp	al, 1
	jne	SHORT $LN42@rundevice

; 261  : 					ppu_internal.shiftreg_nametable = vbus.readmemory(0x2000 | (ppu_internal.v_register & 0x0FFF));

	movzx	eax, WORD PTR [rbx+102]
	lea	rcx, QWORD PTR [rbx+240]
	and	eax, 4095				; 00000fffH
	bts	eax, 13
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp

; 23   : 	address = addr;

	mov	DWORD PTR [rcx], eax

; 24   : 	return read();

	call	?read@bus@@QEAAEXZ			; bus::read
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp

; 261  : 					ppu_internal.shiftreg_nametable = vbus.readmemory(0x2000 | (ppu_internal.v_register & 0x0FFF));

	mov	BYTE PTR [rbx+201], al
	jmp	$LN52@rundevice
$LN42@rundevice:

; 262  : 				}
; 263  : 				else if (cs == 3) {

	cmp	al, 3
	jne	SHORT $LN44@rundevice

; 264  : 					// do garbage nametable read.
; 265  : 					ppu_internal.shiftreg_nametable = vbus.readmemory(0x2000 | (ppu_internal.v_register & 0x0FFF));

	movzx	eax, WORD PTR [rbx+102]
	lea	rcx, QWORD PTR [rbx+240]
	and	eax, 4095				; 00000fffH
	bts	eax, 13
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp

; 23   : 	address = addr;

	mov	DWORD PTR [rcx], eax

; 24   : 	return read();

	call	?read@bus@@QEAAEXZ			; bus::read
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp

; 266  : 					ppu_internal.shiftreg_spr_latch[ppu_internal.n] = ppu_internal.secoam[ppu_internal.n].attr;

	movzx	ecx, BYTE PTR [rbx+160]
	mov	BYTE PTR [rbx+201], al
	movzx	eax, BYTE PTR [rbx+rcx*4+117]
	mov	BYTE PTR [rcx+rbx+185], al
	jmp	$LN52@rundevice
$LN44@rundevice:

; 267  : 				}
; 268  : 				else if (cs == 5) {

	cmp	al, 5
	jne	$LN46@rundevice

; 269  : 					// load pattern table tile low
; 270  : 					byte ltile = ppu_internal.secoam[ppu_internal.n].tile;

	movzx	r11d, BYTE PTR [rbx+160]

; 271  : 					int	 ix = scanline - (ppu_internal.secoam[ppu_internal.n].y);

	mov	r9d, edx

; 272  : 					word pattern_address;
; 273  : 					if (ppuctrl.sprites_8x16) {

	movzx	edi, BYTE PTR [rbx+76]
	movzx	ecx, BYTE PTR [rbx+r11*4+115]
	movzx	r10d, BYTE PTR [rbx+r11*4+116]
	sub	r9d, ecx
	test	dil, dil
	je	SHORT $LN48@rundevice

; 274  : 						pattern_address = (ltile & 1) == 1 ? 0x1000 : 0x0000;

	movzx	eax, r10b
	and	al, 1
	movzx	r8d, al
	shl	r8w, 12

; 275  : 						ltile &= 0xFE;

	and	r10b, 254				; 000000feH

; 276  : 					}
; 277  : 					else {

	jmp	SHORT $LN49@rundevice
$LN48@rundevice:

; 278  : 						pattern_address = (ppuctrl.sprites_0x1000 << 12);

	movzx	r8d, BYTE PTR [rbx+74]
	shl	r8w, 12
$LN49@rundevice:

; 279  : 					}
; 280  : 					// check bit flip horiz.
; 281  : 					if ((ppu_internal.shiftreg_spr_latch[ppu_internal.n] & OAM_SPR_ATTR_FLIP_VER) == OAM_SPR_ATTR_FLIP_VER) {

	cmp	BYTE PTR [r11+rbx+185], r14b
	jge	SHORT $LN100@rundevice

; 282  : 						// inverse ix.
; 283  : 						ix = ppuctrl.sprites_8x16 ? 15 - ix : 7 - ix;

	sub	ecx, edx
	lea	r9d, DWORD PTR [rcx+15]
	test	dil, dil
	jne	SHORT $LN100@rundevice
	lea	r9d, DWORD PTR [rcx+7]
$LN100@rundevice:

; 284  : 					}
; 285  : 					if (ix > 7) pattern_address += 8;
; 286  : 					pattern_address += (ltile << 4) + ix;

	movzx	eax, r10b

; 287  : 					ppu_internal.shiftreg_spr_pattern_lo[ppu_internal.n] = vbus.readmemory(pattern_address);

	lea	edx, DWORD PTR [r8+8]
	cmp	r9d, 7
	lea	rcx, QWORD PTR [rbx+240]
	cmovle	dx, r8w
	shl	ax, 4
	add	dx, ax
	add	dx, r9w
	movzx	eax, dx
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp

; 23   : 	address = addr;

	mov	DWORD PTR [rcx], eax

; 24   : 	return read();

	call	?read@bus@@QEAAEXZ			; bus::read
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp

; 287  : 					ppu_internal.shiftreg_spr_pattern_lo[ppu_internal.n] = vbus.readmemory(pattern_address);

	movzx	ecx, BYTE PTR [rbx+160]
	mov	BYTE PTR [rcx+rbx+169], al

; 288  : 					ppu_internal.shiftreg_spr_counter[ppu_internal.n] = ppu_internal.secoam[ppu_internal.n].x;

	movzx	ecx, BYTE PTR [rbx+160]
	movzx	eax, BYTE PTR [rbx+rcx*4+118]
	mov	BYTE PTR [rcx+rbx+193], al
	jmp	$LN145@rundevice
$LN46@rundevice:

; 289  : 				}
; 290  : 				else if (cs == 7) {

	cmp	al, 7
	jne	$LN52@rundevice

; 291  : 					// load pattern table tile high
; 292  : 					byte ltile = ppu_internal.secoam[ppu_internal.n].tile;

	movzx	r11d, BYTE PTR [rbx+160]

; 293  : 					int	 ix = scanline - (ppu_internal.secoam[ppu_internal.n].y);

	mov	r9d, edx

; 294  : 					word pattern_address;
; 295  : 					if (ppuctrl.sprites_8x16) {

	movzx	edi, BYTE PTR [rbx+76]
	movzx	ecx, BYTE PTR [rbx+r11*4+115]
	movzx	r10d, BYTE PTR [rbx+r11*4+116]
	sub	r9d, ecx
	test	dil, dil
	je	SHORT $LN53@rundevice

; 296  : 						pattern_address = (ltile & 1) == 1 ? 0x1000 : 0x0000;

	movzx	eax, r10b
	and	al, 1
	movzx	r8d, al
	shl	r8w, 12

; 297  : 						ltile &= 0xFE;

	and	r10b, 254				; 000000feH

; 298  : 					}
; 299  : 					else {

	jmp	SHORT $LN54@rundevice
$LN53@rundevice:

; 300  : 						pattern_address = (ppuctrl.sprites_0x1000 << 12);

	movzx	r8d, BYTE PTR [rbx+74]
	shl	r8w, 12
$LN54@rundevice:

; 301  : 					}
; 302  : 					// check bit flip horiz.
; 303  : 					if ((ppu_internal.shiftreg_spr_latch[ppu_internal.n] & OAM_SPR_ATTR_FLIP_VER) == OAM_SPR_ATTR_FLIP_VER) {

	cmp	BYTE PTR [r11+rbx+185], r14b
	jge	SHORT $LN102@rundevice

; 304  : 						// inverse ix.
; 305  : 						ix = ppuctrl.sprites_8x16 ? 15 - ix : 7 - ix;

	sub	ecx, edx
	lea	r9d, DWORD PTR [rcx+15]
	test	dil, dil
	jne	SHORT $LN102@rundevice
	lea	r9d, DWORD PTR [rcx+7]
$LN102@rundevice:

; 306  : 					}					
; 307  : 					if (ix > 7) pattern_address += 8;
; 308  : 					pattern_address += (ltile << 4) + ix;

	movzx	eax, r10b

; 309  : 					ppu_internal.shiftreg_spr_pattern_hi[ppu_internal.n] = vbus.readmemory(pattern_address + 8);

	lea	edx, DWORD PTR [r8+8]
	cmp	r9d, 7
	lea	rcx, QWORD PTR [rbx+240]
	cmovle	dx, r8w
	shl	ax, 4
	add	dx, ax
	add	dx, r9w
	movzx	eax, dx
	add	eax, 8
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\bus.cpp

; 23   : 	address = addr;

	mov	DWORD PTR [rcx], eax

; 24   : 	return read();

	call	?read@bus@@QEAAEXZ			; bus::read
; File c:\users\nightorius.phibian\source\repos\denveremu\denveremu\ppu.cpp

; 309  : 					ppu_internal.shiftreg_spr_pattern_hi[ppu_internal.n] = vbus.readmemory(pattern_address + 8);

	movzx	ecx, BYTE PTR [rbx+160]
	mov	BYTE PTR [rcx+rbx+177], al

; 310  : 					ppu_internal.shiftreg_spr_counter[ppu_internal.n] = ppu_internal.secoam[ppu_internal.n].x;

	movzx	ecx, BYTE PTR [rbx+160]
	movzx	eax, BYTE PTR [rbx+rcx*4+118]
	mov	BYTE PTR [rcx+rbx+193], al

; 311  : 					ppu_internal.n++;	// eval to next sprite in seconday oam. this will never go over 7, because eval will stop earlier.

	inc	BYTE PTR [rbx+160]
$LN145@rundevice:

; 312  : 				}
; 313  : 			}
; 314  : 			// addressing cycle.
; 315  : 			if (cycle == 257) {

	mov	edi, 64480				; 0000fbe0H
$LN52@rundevice:
	mov	r8d, DWORD PTR [rbx+220]
	cmp	r8d, 257				; 00000101H
	jne	SHORT $LN135@rundevice

; 316  : 				ppu_internal.v_register = (ppu_internal.v_register & ~0x041F) | (ppu_internal.t_register & 0x041F);

	movzx	eax, WORD PTR [rbx+100]
	mov	ecx, 1055				; 0000041fH
	and	WORD PTR [rbx+102], di
	and	ax, cx
	or	WORD PTR [rbx+102], ax
$LN135@rundevice:

; 317  : 			}
; 318  : 			// loopy_v cycle (hori) @ 257
; 319  : 			//std::cout << std::dec << cycle << ", ";
; 320  : 			if (cycle == 256) {

	cmp	r8d, 256				; 00000100H
	jne	SHORT $LN60@rundevice

; 321  : 				if ((ppu_internal.v_register & 0x7000) != 0x7000) {

	movzx	ecx, WORD PTR [rbx+102]
	movzx	eax, cx
	and	ax, r13w
	cmp	ax, r13w
	je	SHORT $LN59@rundevice

; 322  : 					ppu_internal.v_register += 0x1000;

	mov	eax, 4096				; 00001000H
	add	cx, ax
	mov	WORD PTR [rbx+102], cx

; 323  : 				}
; 324  : 				else {

	jmp	SHORT $LN146@rundevice
$LN59@rundevice:

; 325  : 					ppu_internal.v_register &= ~0x7000;

	mov	eax, 36863				; 00008fffH
	and	cx, ax

; 326  : 					int y = ((ppu_internal.v_register & 0x03E0) >> 5);

	mov	eax, ecx
	shr	eax, 5
	and	eax, 31

; 327  : 					if (y == 29) {

	cmp	eax, 29
	jne	SHORT $LN61@rundevice

; 328  : 						y = 0;
; 329  : 						ppu_internal.v_register ^= 0x0800;

	mov	edx, 2048				; 00000800H
	mov	eax, r14d
	xor	cx, dx
	jmp	SHORT $LN64@rundevice
$LN61@rundevice:

; 330  : 					}
; 331  : 					else if (y == 31) {

	cmp	eax, 31
	jne	SHORT $LN63@rundevice

; 332  : 						y = 0;

	mov	eax, r14d

; 333  : 					}
; 334  : 					else {

	jmp	SHORT $LN64@rundevice
$LN63@rundevice:

; 335  : 						y++;

	inc	eax
$LN64@rundevice:

; 336  : 					}
; 337  : 					ppu_internal.v_register = (ppu_internal.v_register & ~0x03E0) | (y << 5);

	mov	edx, 64543				; 0000fc1fH
	shl	ax, 5
	and	cx, dx
	or	ax, cx
	mov	WORD PTR [rbx+102], ax
$LN146@rundevice:

; 338  : 				}
; 339  : 			}
; 340  : 		}
; 341  : 		// BG/SPR rendering cycles.
; 342  : 		if ((scanline >= 0) && (scanline <= 239)) {

	mov	r8d, 256				; 00000100H
$LN60@rundevice:
	mov	eax, DWORD PTR [rbx+212]
	mov	ecx, r8d
	mov	edx, eax
	test	eax, eax
	js	$LN66@rundevice
	cmp	eax, 239				; 000000efH
	jg	$LN66@rundevice

; 343  : 			if ((cycle >= 0) && (cycle <= 259)) {

	test	r8d, r8d
	js	$LN66@rundevice
	cmp	r8d, 259				; 00000103H
	jg	$LN66@rundevice

; 344  : 				if (ppumask.showspr) {

	cmp	BYTE PTR [rbx+83], r14b
	je	$LN8@rundevice

; 345  : 					// decrement counters.
; 346  : 					for (int i = 0; i < 8; i++) {

	mov	rdi, r14
	npad	4
$LL9@rundevice:

; 347  : 						// check if count is zero then render the pattern buffers.
; 348  : 						if (ppu_internal.shiftreg_spr_counter[i] == 0) {

	movzx	r9d, BYTE PTR [rdi+rbx+193]
	test	r9b, r9b
	jne	$LN71@rundevice

; 349  : 							// we can get the pixel two ways depending on OAM_SPR_ATTR_FLIP_VER
; 350  : 							byte pix = 0;
; 351  : 							if ((ppu_internal.shiftreg_spr_latch[i] & OAM_SPR_ATTR_FLIP_HOR) == OAM_SPR_ATTR_FLIP_HOR) {

	movzx	r10d, BYTE PTR [rdi+rbx+185]
	movzx	ecx, BYTE PTR [rdi+rbx+177]
	movzx	r8d, BYTE PTR [rdi+rbx+169]
	movzx	edx, cl
	movzx	eax, r8b
	test	r10b, 64				; 00000040H
	je	SHORT $LN69@rundevice

; 352  : 								// flipped.
; 353  : 								pix = ppu_internal.shiftreg_spr_pattern_lo[i] & 0x01;
; 354  : 								pix |= (ppu_internal.shiftreg_spr_pattern_hi[i] & 0x01) << 1;

	and	dl, 1

; 355  : 								ppu_internal.shiftreg_spr_pattern_lo[i] >>= 1;
; 356  : 								ppu_internal.shiftreg_spr_pattern_hi[i] >>= 1;

	shr	cl, 1
	add	dl, dl
	and	al, 1
	or	dl, al
	shr	r8b, 1

; 357  : 							}
; 358  : 							else {

	jmp	SHORT $LN70@rundevice
$LN69@rundevice:

; 359  : 								// normal.
; 360  : 								pix = (ppu_internal.shiftreg_spr_pattern_lo[i] & 0x80) >> 7;

	and	dl, 191					; 000000bfH
	shr	al, 1

; 361  : 								pix |= (ppu_internal.shiftreg_spr_pattern_hi[i] & 0x80) >> 6;

	or	dl, al

; 362  : 								ppu_internal.shiftreg_spr_pattern_lo[i] <<= 1;
; 363  : 								ppu_internal.shiftreg_spr_pattern_hi[i] <<= 1;

	add	cl, cl
	shr	dl, 6
	add	r8b, r8b
$LN70@rundevice:

; 364  : 							}
; 365  : 
; 366  : 							// get pixel color.
; 367  : 							byte spr_palette = (ppu_internal.shiftreg_spr_latch[i] & OAM_SPR_ATTR_PALETTE);

	and	r10b, 3
	mov	BYTE PTR [rdi+rbx+169], r8b
	mov	BYTE PTR [rdi+rbx+177], cl

; 368  : 							if (pix > 0) {

	test	dl, dl
	je	SHORT $LN71@rundevice

; 369  : 								ppu_internal.spr_pix = pix;
; 370  : 								ppu_internal.spr_pix_pal = vpal.read(0, 0x10 | spr_palette << 2 | pix);

	movzx	eax, dl
	lea	rcx, QWORD PTR [rbx+280]
	mov	r9, QWORD PTR [rcx]
	movzx	r8d, r10b
	or	r8d, 4
	mov	BYTE PTR [rbx+163], dl
	shl	r8d, 2
	xor	edx, edx
	or	r8d, eax
	call	QWORD PTR [r9+32]
	mov	BYTE PTR [rbx+164], al
	movzx	r9d, BYTE PTR [rdi+rbx+193]
$LN71@rundevice:

; 371  : 							}
; 372  : 						}
; 373  : 						// decrement counter register.
; 374  : 						if (ppu_internal.shiftreg_spr_counter[i] < 255)

	cmp	r9b, 255				; 000000ffH
	jae	SHORT $LN7@rundevice

; 375  : 							ppu_internal.shiftreg_spr_counter[i] = ppu_internal.shiftreg_spr_counter[i] > 0 ? ppu_internal.shiftreg_spr_counter[i] - 1 : 0;

	lea	eax, DWORD PTR [r9-1]
	test	r9b, r9b
	movzx	ecx, al
	cmove	ecx, r14d
	mov	BYTE PTR [rdi+rbx+193], cl
$LN7@rundevice:

; 345  : 					// decrement counters.
; 346  : 					for (int i = 0; i < 8; i++) {

	inc	rdi
	cmp	rdi, 8
	jl	$LL9@rundevice
$LN8@rundevice:

; 376  : 					}
; 377  : 				}
; 378  : 				if (ppumask.showbg) {				

	cmp	BYTE PTR [rbx+82], r14b
	je	$LN73@rundevice

; 379  : 					// get the pixel.
; 380  : 					word pix_mux = 0x8000 >> ppu_internal.x_shift;

	movzx	ecx, BYTE PTR [rbx+97]

; 381  : 					byte palentry = (((ppu_internal.shiftregs_pattern[1] & pix_mux) > 0) << 1) |
; 382  : 						((ppu_internal.shiftregs_pattern[0] & pix_mux) > 0);
; 383  : 
; 384  : 					byte color = (((ppu_internal.shiftreg_attribute[1] & pix_mux) > 0) << 1) |
; 385  : 						((ppu_internal.shiftreg_attribute[0] & pix_mux) > 0);
; 386  : 					
; 387  : 					color <<= 2;
; 388  : 					
; 389  : 
; 390  : 					// convert color from the palette entry!
; 391  : 					//color = vbus.readmemory ((color | 0x3F00) | palentry);
; 392  : 					// no need for full bus emulation on color data.
; 393  : 					color = vpal.read(0, color | palentry);	// addr = 0x000 (vpal ignores that anyway)

	mov	eax, 8
	mov	r10d, 4
	mov	edx, 32768				; 00008000H
	sar	edx, cl
	mov	r8d, r14d
	test	WORD PTR [rbx+112], dx
	lea	rcx, QWORD PTR [rbx+280]
	mov	r9, QWORD PTR [rcx]
	cmova	r8d, eax
	test	WORD PTR [rbx+110], dx
	mov	eax, r14d
	cmova	eax, r10d
	mov	r10d, 2
	or	r8d, eax
	mov	eax, r14d
	test	WORD PTR [rbx+108], dx
	cmova	eax, r10d
	or	r8d, eax
	mov	eax, r14d
	test	WORD PTR [rbx+106], dx
	seta	al
	xor	edx, edx
	or	r8d, eax
	call	QWORD PTR [r9+32]

; 394  : 
; 395  : 					// shift the registers.
; 396  : 					ppu_internal.shiftregs_pattern[0] <<= 1;

	shl	WORD PTR [rbx+106], 1

; 397  : 					ppu_internal.shiftregs_pattern[1] <<= 1;

	shl	WORD PTR [rbx+108], 1

; 398  : 					ppu_internal.shiftreg_attribute[0] <<= 1;

	shl	WORD PTR [rbx+110], 1

; 399  : 					ppu_internal.shiftreg_attribute[1] <<= 1;

	shl	WORD PTR [rbx+112], 1

; 400  : 
; 401  : 					// draw to framebuffer?
; 402  : 					if (beam<256) {

	movsxd	r8, DWORD PTR [rbx+216]
	cmp	r8d, 256				; 00000100H
	jge	$LN74@rundevice

; 403  : 						framebuffer[scanline << 8 | beam] = color; // (palentry << 4) | (palentry << 4) << 8;

	movzx	edx, al
	mov	eax, DWORD PTR [rbx+212]
	shl	eax, 8
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx+224]
	or	rcx, r8
	mov	WORD PTR [rax+rcx*2], dx

; 404  : 						framebuffer[scanline << 8 | beam] |= (ppumask.emp_blu ? 0x0100 : 0) |

	mov	eax, DWORD PTR [rbx+212]
	shl	eax, 8
	movsxd	rcx, eax
	movsxd	rax, DWORD PTR [rbx+216]
	or	rcx, rax
	mov	rax, QWORD PTR [rbx+224]
	lea	r8, QWORD PTR [rax+rcx*2]
	movzx	eax, BYTE PTR [rbx+84]
	neg	al
	movzx	eax, BYTE PTR [rbx+85]
	sbb	dx, dx
	and	dx, 1024				; 00000400H
	neg	al
	movzx	eax, BYTE PTR [rbx+86]
	sbb	cx, cx
	and	cx, 512					; 00000200H
	or	dx, cx
	neg	al
	sbb	cx, cx
	and	cx, 256					; 00000100H
	or	dx, cx
	or	WORD PTR [r8], dx

; 405  : 							(ppumask.emp_grn ? 0x0200 : 0) |
; 406  : 							(ppumask.emp_red ? 0x0400 : 0);
; 407  : 
; 408  : 						// spr_pix>0 just render for now.
; 409  : 						if (ppu_internal.spr_pix > 0) {

	cmp	BYTE PTR [rbx+163], r14b
	jbe	SHORT $LN74@rundevice

; 410  : 							framebuffer[scanline << 8 | beam] = ppu_internal.spr_pix_pal;

	mov	eax, DWORD PTR [rbx+212]
	movzx	edx, BYTE PTR [rbx+164]
	shl	eax, 8
	movsxd	rcx, eax
	movsxd	rax, DWORD PTR [rbx+216]
	or	rcx, rax
	mov	rax, QWORD PTR [rbx+224]
	mov	WORD PTR [rax+rcx*2], dx

; 411  : 							ppu_internal.spr_pix = 0;

	mov	BYTE PTR [rbx+163], r14b

; 412  : 						}						
; 413  : 					}
; 414  : 				}

	jmp	SHORT $LN74@rundevice
$LN73@rundevice:

; 415  : 				else framebuffer[scanline << 8 | beam] = vram.read(0x00, 0x3F00);

	lea	rcx, QWORD PTR [rbx+360]
	xor	edx, edx
	mov	rax, QWORD PTR [rcx]
	mov	r8d, 16128				; 00003f00H
	call	QWORD PTR [rax+32]
	movzx	edx, al
	mov	eax, DWORD PTR [rbx+212]
	shl	eax, 8
	movsxd	rcx, eax
	movsxd	rax, DWORD PTR [rbx+216]
	or	rcx, rax
	mov	rax, QWORD PTR [rbx+224]
	mov	WORD PTR [rax+rcx*2], dx
$LN74@rundevice:

; 416  : 				if ((scanline == oam[0].y) && (beam == oam[0].x+2)) ppustatus.sprite_0_hit = true;	// fake it for now.

	movzx	eax, BYTE PTR [rbx+440]
	mov	edx, DWORD PTR [rbx+212]
	cmp	edx, eax
	jne	SHORT $LN77@rundevice
	movzx	eax, BYTE PTR [rbx+443]
	add	eax, 2
	cmp	DWORD PTR [rbx+216], eax
	jne	SHORT $LN77@rundevice
	mov	BYTE PTR [rbx+88], 1
$LN77@rundevice:

; 417  : 				beam++;

	inc	DWORD PTR [rbx+216]
	mov	ecx, DWORD PTR [rbx+220]
$LN66@rundevice:

; 418  : 			}
; 419  : 		}
; 420  : 		// flags and nmi.
; 421  : 		if ((scanline == 241) && (cycle == 1)) {

	cmp	edx, 241				; 000000f1H
	jne	SHORT $LN79@rundevice
	mov	ecx, DWORD PTR [rbx+220]
	cmp	ecx, 1
	jne	SHORT $LN79@rundevice

; 422  : 			// set vblank flag and raise NMI if enabled.
; 423  : 			ppustatus.vblank = true;

	mov	BYTE PTR [rbx+89], cl

; 424  : 			if (ppuctrl.do_nmi) nmi_enable = true;	// nmi enabled gets automaticly pulled up by bus device.

	cmp	BYTE PTR [rbx+78], r14b
	je	SHORT $LN79@rundevice
	mov	BYTE PTR [rbx+21], cl
$LN79@rundevice:

; 425  : 		}
; 426  : 
; 427  : 		if (scanline == 261) {

	cmp	edx, 261				; 00000105H
	jne	SHORT $LN83@rundevice

; 428  : 			if (cycle == 1) {

	mov	r8d, DWORD PTR [rbx+220]
	cmp	r8d, 1
	jne	SHORT $LN81@rundevice

; 429  : 				// reset flags.
; 430  : 				ppustatus.vblank = false;
; 431  : 				ppustatus.sprite_0_hit = false;

	mov	WORD PTR [rbx+88], r14w

; 432  : 				ppustatus.sprite_overflow = false;

	mov	BYTE PTR [rbx+87], r14b
$LN81@rundevice:

; 433  : 			}
; 434  : 			if ((cycle >= 280) && (cycle <= 304)) {

	mov	ecx, r8d
	cmp	r8d, 280				; 00000118H
	jl	SHORT $LN83@rundevice
	cmp	r8d, 304				; 00000130H
	jg	SHORT $LN83@rundevice

; 435  : 				// reload v register from parts of the t register.
; 436  : 				if (ppumask.showbg || ppumask.showspr) {

	cmp	BYTE PTR [rbx+82], r14b
	jne	SHORT $LN84@rundevice
	cmp	BYTE PTR [rbx+83], r14b
	je	SHORT $LN83@rundevice
$LN84@rundevice:

; 437  : 					ppu_internal.v_register = (ppu_internal.v_register & ~0x7BE0) | (ppu_internal.t_register & 0x7BE0);

	mov	eax, 33823				; 0000841fH
	mov	ecx, 31712				; 00007be0H
	and	WORD PTR [rbx+102], ax
	movzx	eax, WORD PTR [rbx+100]
	and	ax, cx
	mov	ecx, r8d
	or	WORD PTR [rbx+102], ax
$LN83@rundevice:

; 438  : 				}
; 439  : 			}
; 440  : 		}
; 441  : 
; 442  : 		// Scanline..
; 443  : 		if (cycle == 339) {

	cmp	ecx, 339				; 00000153H
	jne	SHORT $LN87@rundevice

; 444  : 			scanline++;

	inc	edx

; 445  : 			beam = 0;

	mov	DWORD PTR [rbx+216], r14d
	mov	DWORD PTR [rbx+212], edx

; 446  : 			// framebuffer done.
; 447  : 			if (scanline == 240) {

	cmp	edx, 240				; 000000f0H
	jne	SHORT $LN86@rundevice

; 448  : 				frameready = true;

	mov	BYTE PTR [rbx+232], 1
$LN86@rundevice:

; 449  : 			}
; 450  : 			if (scanline == 262) {

	mov	ecx, 339				; 00000153H
	cmp	edx, 262				; 00000106H
	jne	SHORT $LN87@rundevice

; 451  : 				scanline = 0;
; 452  : 				if (ppu_internal.odd_even_frame) cycle = 340;

	movzx	eax, BYTE PTR [rbx+202]
	test	al, al
	mov	DWORD PTR [rbx+212], r14d

; 453  : 				ppu_internal.odd_even_frame = !ppu_internal.odd_even_frame;

	sete	al
	cmovne	ecx, r12d
	mov	BYTE PTR [rbx+202], al
$LN87@rundevice:

; 454  : 			}
; 455  : 		}
; 456  : 		cycle++; 

	lea	r8d, DWORD PTR [rcx+1]
	mov	DWORD PTR [rbx+220], r8d

; 457  : 		if (cycle == 340) {			

	mov	r9d, r8d
	cmp	r8d, r12d
	jne	SHORT $LN2@rundevice

; 458  : 			cycle = 0;

	mov	DWORD PTR [rbx+220], r14d
	mov	r8d, r14d
	mov	r9d, r14d
$LN2@rundevice:

; 135  : 	// run the PPU..
; 136  : 	for (int i = 0; i < ticks; i++) {

	mov	r10d, 8
	inc	esi
	mov	edi, 64480				; 0000fbe0H
	lea	r11d, QWORD PTR [r10+8]
	cmp	esi, ebp
	jl	$LL4@rundevice

; 459  : 		}
; 460  : 	}
; 461  : 	return ticks;	// assume ticks in = ticks out.

	mov	r15, QWORD PTR [rsp+32]
	mov	r13, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+80]
$LN142@rundevice:

; 462  : }

	mov	eax, ebp
	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?rundevice@ppu@@UEAAHH@Z ENDP				; ppu::rundevice
_TEXT	ENDS
END
